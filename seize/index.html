<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="`seize`"><title>seize - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-1a91846b.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="seize" data-themes="" data-resource-suffix="" data-rustdoc-version="1.88.0 (6b00bc388 2025-06-23)" data-channel="1.88.0" data-search-js="search-f7877310.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-4e99c027.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-7ef8a74a.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../seize/index.html">seize</a><span class="version">0.5.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#seize" title="`seize`"><code>seize</code></a><ul><li><a href="#background" title="Background">Background</a></li><li><a href="#implementation" title="Implementation">Implementation</a></li></ul></li></ul><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#traits" title="Traits">Traits</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>seize</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/seize/lib.rs.html#1-13">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="seize"><a class="doc-anchor" href="#seize">§</a><code>seize</code></h2>
<p><a href="https://crates.io/crates/seize"><img alt="crates.io" src="https://img.shields.io/crates/v/seize?style=for-the-badge" height="25"></a>
<a href="https://github.com/ibraheemdev/seize"><img alt="github" src="https://img.shields.io/badge/github-seize-blue?style=for-the-badge" height="25"></a>
<a href="https://docs.rs/seize"><img alt="docs.rs" src="https://img.shields.io/docsrs/seize?style=for-the-badge" height="25"></a></p>
<p>Fast, efficient, and predictable memory reclamation for concurrent data
structures.</p>
<p>Refer to the <a href="https://docs.rs/seize/latest/seize/guide/index.html">quick-start guide</a> to get started.</p>
<h3 id="background"><a class="doc-anchor" href="#background">§</a>Background</h3>
<p>Concurrent data structures are faced with the problem of deciding when it is
safe to free memory. Despite an object being logically removed, it may still be
accessible by other threads that are holding references to it, and thus it is
not safe to free immediately. Over the years, many algorithms have been devised
to solve this problem. However, most traditional memory reclamation schemes make
a tradeoff between performance and efficiency.</p>
<p>For example, <a href="https://www.cs.otago.ac.nz/cosc440/readings/hazard-pointers.pdf">hazard pointers</a> track individual pointers, making them very
memory efficient but also relatively slow. On the other hand, <a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-579.pdf">epoch based
reclamation</a> is fast and lightweight, but lacks predictability, requiring
periodic checks to determine when it is safe to free memory. This can cause
reclamation to trigger unpredictably, leading to poor latency distributions.</p>
<p>Alternative epoch-based schemes forgo workload balancing, relying on the thread
that retires an object always being the one that frees it. While this can avoid
synchronization costs, it also leads to unbalanced reclamation in read-dominated
workloads; parallelism is reduced when only a fraction of threads are writing,
degrading memory efficiency as well as performance.</p>
<h3 id="implementation"><a class="doc-anchor" href="#implementation">§</a>Implementation</h3>
<p><code>seize</code> is based on the <a href="https://arxiv.org/pdf/1905.07903.pdf">hyaline reclamation scheme</a>, which uses reference
counting to determine when it is safe to free memory. However, unlike
traditional reference counting schemes where every memory access requires
modifying shared memory, reference counters are only used for retired objects.
When a batch of objects is retired, a reference counter is initialized and
propagated to all active threads. Threads cooperate to decrement the reference
counter as they exit, eventually freeing the batch. Reclamation is naturally
balanced as the thread with the last reference to an object is the one that
frees it. This also removes the need to check whether other threads have made
progress, leading to predictable latency without sacrificing performance.</p>
<p><code>seize</code> provides performance competitive with that of epoch based schemes, while
memory efficiency is similar to that of hazard pointers. <code>seize</code> is compatible
with all modern hardware that supports single-word atomic operations such as FAA
and CAS.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="guide/index.html" title="mod seize::guide">guide</a></dt><dd>A quick-start guide for working with <code>seize</code>.</dd><dt><a class="mod" href="reclaim/index.html" title="mod seize::reclaim">reclaim</a></dt><dd>Common memory reclaimers.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Collector.html" title="struct seize::Collector">Collector</a></dt><dd>A concurrent garbage collector.</dd><dt><a class="struct" href="struct.LocalGuard.html" title="struct seize::LocalGuard">Local<wbr>Guard</a></dt><dd>A guard that keeps the current thread marked as active.</dd><dt><a class="struct" href="struct.OwnedGuard.html" title="struct seize::OwnedGuard">Owned<wbr>Guard</a></dt><dd>A guard that protects objects for it’s lifetime, independent of the current
thread.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.Guard.html" title="trait seize::Guard">Guard</a></dt><dd>A guard that enables protected loads of concurrent objects.</dd></dl></section></div></main></body></html>