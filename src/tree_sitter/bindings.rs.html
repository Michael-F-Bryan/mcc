<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tree-sitter-0.25.8/binding_rust/./bindings.rs`."><title>bindings.rs - source</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-1a91846b.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="tree_sitter" data-themes="" data-resource-suffix="" data-rustdoc-version="1.88.0 (6b00bc388 2025-06-23)" data-channel="1.88.0" data-search-js="search-f7877310.js" data-settings-js="settings-5514c975.js" ><script src="../../static.files/storage-4e99c027.js"></script><script defer src="../../static.files/src-script-63605ae7.js"></script><script defer src="../../src-files.js"></script><script defer src="../../static.files/main-7ef8a74a.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="src-sidebar-title"><h2>Files</h2></div></nav><div class="sidebar-resizer"></div><main><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1><div class="sub-heading">tree_sitter/</div>bindings.rs</h1><rustdoc-toolbar></rustdoc-toolbar></div><div class="example-wrap digits-3"><pre class="rust"><code><a href=#1 id=1 data-nosnippet>1</a><span class="comment">/* automatically generated by rust-bindgen 0.71.1 */
<a href=#2 id=2 data-nosnippet>2</a>
<a href=#3 id=3 data-nosnippet>3</a></span><span class="kw">pub const </span>TREE_SITTER_LANGUAGE_VERSION: u32 = <span class="number">15</span>;
<a href=#4 id=4 data-nosnippet>4</a><span class="kw">pub const </span>TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION: u32 = <span class="number">13</span>;
<a href=#5 id=5 data-nosnippet>5</a><span class="kw">pub type </span>TSStateId = u16;
<a href=#6 id=6 data-nosnippet>6</a><span class="kw">pub type </span>TSSymbol = u16;
<a href=#7 id=7 data-nosnippet>7</a><span class="kw">pub type </span>TSFieldId = u16;
<a href=#8 id=8 data-nosnippet>8</a><span class="attr">#[repr(C)]
<a href=#9 id=9 data-nosnippet>9</a>#[derive(Debug)]
<a href=#10 id=10 data-nosnippet>10</a></span><span class="kw">pub struct </span>TSLanguage {
<a href=#11 id=11 data-nosnippet>11</a>    _unused: [u8; <span class="number">0</span>],
<a href=#12 id=12 data-nosnippet>12</a>}
<a href=#13 id=13 data-nosnippet>13</a><span class="attr">#[repr(C)]
<a href=#14 id=14 data-nosnippet>14</a>#[derive(Debug)]
<a href=#15 id=15 data-nosnippet>15</a></span><span class="kw">pub struct </span>TSParser {
<a href=#16 id=16 data-nosnippet>16</a>    _unused: [u8; <span class="number">0</span>],
<a href=#17 id=17 data-nosnippet>17</a>}
<a href=#18 id=18 data-nosnippet>18</a><span class="attr">#[repr(C)]
<a href=#19 id=19 data-nosnippet>19</a>#[derive(Debug)]
<a href=#20 id=20 data-nosnippet>20</a></span><span class="kw">pub struct </span>TSTree {
<a href=#21 id=21 data-nosnippet>21</a>    _unused: [u8; <span class="number">0</span>],
<a href=#22 id=22 data-nosnippet>22</a>}
<a href=#23 id=23 data-nosnippet>23</a><span class="attr">#[repr(C)]
<a href=#24 id=24 data-nosnippet>24</a>#[derive(Debug)]
<a href=#25 id=25 data-nosnippet>25</a></span><span class="kw">pub struct </span>TSQuery {
<a href=#26 id=26 data-nosnippet>26</a>    _unused: [u8; <span class="number">0</span>],
<a href=#27 id=27 data-nosnippet>27</a>}
<a href=#28 id=28 data-nosnippet>28</a><span class="attr">#[repr(C)]
<a href=#29 id=29 data-nosnippet>29</a>#[derive(Debug)]
<a href=#30 id=30 data-nosnippet>30</a></span><span class="kw">pub struct </span>TSQueryCursor {
<a href=#31 id=31 data-nosnippet>31</a>    _unused: [u8; <span class="number">0</span>],
<a href=#32 id=32 data-nosnippet>32</a>}
<a href=#33 id=33 data-nosnippet>33</a><span class="attr">#[repr(C)]
<a href=#34 id=34 data-nosnippet>34</a>#[derive(Debug)]
<a href=#35 id=35 data-nosnippet>35</a></span><span class="kw">pub struct </span>TSLookaheadIterator {
<a href=#36 id=36 data-nosnippet>36</a>    _unused: [u8; <span class="number">0</span>],
<a href=#37 id=37 data-nosnippet>37</a>}
<a href=#38 id=38 data-nosnippet>38</a><span class="kw">pub type </span>DecodeFunction = ::core::option::Option&lt;
<a href=#39 id=39 data-nosnippet>39</a>    <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn</span>(string: <span class="kw-2">*const </span>u8, length: u32, code_point: <span class="kw-2">*mut </span>i32) -&gt; u32,
<a href=#40 id=40 data-nosnippet>40</a>&gt;;
<a href=#41 id=41 data-nosnippet>41</a><span class="kw">pub const </span>TSInputEncodingUTF8: TSInputEncoding = <span class="number">0</span>;
<a href=#42 id=42 data-nosnippet>42</a><span class="kw">pub const </span>TSInputEncodingUTF16LE: TSInputEncoding = <span class="number">1</span>;
<a href=#43 id=43 data-nosnippet>43</a><span class="kw">pub const </span>TSInputEncodingUTF16BE: TSInputEncoding = <span class="number">2</span>;
<a href=#44 id=44 data-nosnippet>44</a><span class="kw">pub const </span>TSInputEncodingCustom: TSInputEncoding = <span class="number">3</span>;
<a href=#45 id=45 data-nosnippet>45</a><span class="kw">pub type </span>TSInputEncoding = ::core::ffi::c_uint;
<a href=#46 id=46 data-nosnippet>46</a><span class="kw">pub const </span>TSSymbolTypeRegular: TSSymbolType = <span class="number">0</span>;
<a href=#47 id=47 data-nosnippet>47</a><span class="kw">pub const </span>TSSymbolTypeAnonymous: TSSymbolType = <span class="number">1</span>;
<a href=#48 id=48 data-nosnippet>48</a><span class="kw">pub const </span>TSSymbolTypeSupertype: TSSymbolType = <span class="number">2</span>;
<a href=#49 id=49 data-nosnippet>49</a><span class="kw">pub const </span>TSSymbolTypeAuxiliary: TSSymbolType = <span class="number">3</span>;
<a href=#50 id=50 data-nosnippet>50</a><span class="kw">pub type </span>TSSymbolType = ::core::ffi::c_uint;
<a href=#51 id=51 data-nosnippet>51</a><span class="attr">#[repr(C)]
<a href=#52 id=52 data-nosnippet>52</a>#[derive(Debug, Copy, Clone)]
<a href=#53 id=53 data-nosnippet>53</a></span><span class="kw">pub struct </span>TSPoint {
<a href=#54 id=54 data-nosnippet>54</a>    <span class="kw">pub </span>row: u32,
<a href=#55 id=55 data-nosnippet>55</a>    <span class="kw">pub </span>column: u32,
<a href=#56 id=56 data-nosnippet>56</a>}
<a href=#57 id=57 data-nosnippet>57</a><span class="attr">#[repr(C)]
<a href=#58 id=58 data-nosnippet>58</a>#[derive(Debug, Copy, Clone)]
<a href=#59 id=59 data-nosnippet>59</a></span><span class="kw">pub struct </span>TSRange {
<a href=#60 id=60 data-nosnippet>60</a>    <span class="kw">pub </span>start_point: TSPoint,
<a href=#61 id=61 data-nosnippet>61</a>    <span class="kw">pub </span>end_point: TSPoint,
<a href=#62 id=62 data-nosnippet>62</a>    <span class="kw">pub </span>start_byte: u32,
<a href=#63 id=63 data-nosnippet>63</a>    <span class="kw">pub </span>end_byte: u32,
<a href=#64 id=64 data-nosnippet>64</a>}
<a href=#65 id=65 data-nosnippet>65</a><span class="attr">#[repr(C)]
<a href=#66 id=66 data-nosnippet>66</a>#[derive(Debug)]
<a href=#67 id=67 data-nosnippet>67</a></span><span class="kw">pub struct </span>TSInput {
<a href=#68 id=68 data-nosnippet>68</a>    <span class="kw">pub </span>payload: <span class="kw-2">*mut </span>::core::ffi::c_void,
<a href=#69 id=69 data-nosnippet>69</a>    <span class="kw">pub </span>read: ::core::option::Option&lt;
<a href=#70 id=70 data-nosnippet>70</a>        <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn</span>(
<a href=#71 id=71 data-nosnippet>71</a>            payload: <span class="kw-2">*mut </span>::core::ffi::c_void,
<a href=#72 id=72 data-nosnippet>72</a>            byte_index: u32,
<a href=#73 id=73 data-nosnippet>73</a>            position: TSPoint,
<a href=#74 id=74 data-nosnippet>74</a>            bytes_read: <span class="kw-2">*mut </span>u32,
<a href=#75 id=75 data-nosnippet>75</a>        ) -&gt; <span class="kw-2">*const </span>::core::ffi::c_char,
<a href=#76 id=76 data-nosnippet>76</a>    &gt;,
<a href=#77 id=77 data-nosnippet>77</a>    <span class="kw">pub </span>encoding: TSInputEncoding,
<a href=#78 id=78 data-nosnippet>78</a>    <span class="kw">pub </span>decode: DecodeFunction,
<a href=#79 id=79 data-nosnippet>79</a>}
<a href=#80 id=80 data-nosnippet>80</a><span class="attr">#[repr(C)]
<a href=#81 id=81 data-nosnippet>81</a>#[derive(Debug, Copy, Clone)]
<a href=#82 id=82 data-nosnippet>82</a></span><span class="kw">pub struct </span>TSParseState {
<a href=#83 id=83 data-nosnippet>83</a>    <span class="kw">pub </span>payload: <span class="kw-2">*mut </span>::core::ffi::c_void,
<a href=#84 id=84 data-nosnippet>84</a>    <span class="kw">pub </span>current_byte_offset: u32,
<a href=#85 id=85 data-nosnippet>85</a>    <span class="kw">pub </span>has_error: bool,
<a href=#86 id=86 data-nosnippet>86</a>}
<a href=#87 id=87 data-nosnippet>87</a><span class="attr">#[repr(C)]
<a href=#88 id=88 data-nosnippet>88</a>#[derive(Debug, Copy, Clone)]
<a href=#89 id=89 data-nosnippet>89</a></span><span class="kw">pub struct </span>TSParseOptions {
<a href=#90 id=90 data-nosnippet>90</a>    <span class="kw">pub </span>payload: <span class="kw-2">*mut </span>::core::ffi::c_void,
<a href=#91 id=91 data-nosnippet>91</a>    <span class="kw">pub </span>progress_callback:
<a href=#92 id=92 data-nosnippet>92</a>        ::core::option::Option&lt;<span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn</span>(state: <span class="kw-2">*mut </span>TSParseState) -&gt; bool&gt;,
<a href=#93 id=93 data-nosnippet>93</a>}
<a href=#94 id=94 data-nosnippet>94</a><span class="kw">pub const </span>TSLogTypeParse: TSLogType = <span class="number">0</span>;
<a href=#95 id=95 data-nosnippet>95</a><span class="kw">pub const </span>TSLogTypeLex: TSLogType = <span class="number">1</span>;
<a href=#96 id=96 data-nosnippet>96</a><span class="kw">pub type </span>TSLogType = ::core::ffi::c_uint;
<a href=#97 id=97 data-nosnippet>97</a><span class="attr">#[repr(C)]
<a href=#98 id=98 data-nosnippet>98</a>#[derive(Debug)]
<a href=#99 id=99 data-nosnippet>99</a></span><span class="kw">pub struct </span>TSLogger {
<a href=#100 id=100 data-nosnippet>100</a>    <span class="kw">pub </span>payload: <span class="kw-2">*mut </span>::core::ffi::c_void,
<a href=#101 id=101 data-nosnippet>101</a>    <span class="kw">pub </span>log: ::core::option::Option&lt;
<a href=#102 id=102 data-nosnippet>102</a>        <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn</span>(
<a href=#103 id=103 data-nosnippet>103</a>            payload: <span class="kw-2">*mut </span>::core::ffi::c_void,
<a href=#104 id=104 data-nosnippet>104</a>            log_type: TSLogType,
<a href=#105 id=105 data-nosnippet>105</a>            buffer: <span class="kw-2">*const </span>::core::ffi::c_char,
<a href=#106 id=106 data-nosnippet>106</a>        ),
<a href=#107 id=107 data-nosnippet>107</a>    &gt;,
<a href=#108 id=108 data-nosnippet>108</a>}
<a href=#109 id=109 data-nosnippet>109</a><span class="attr">#[repr(C)]
<a href=#110 id=110 data-nosnippet>110</a>#[derive(Debug, Copy, Clone)]
<a href=#111 id=111 data-nosnippet>111</a></span><span class="kw">pub struct </span>TSInputEdit {
<a href=#112 id=112 data-nosnippet>112</a>    <span class="kw">pub </span>start_byte: u32,
<a href=#113 id=113 data-nosnippet>113</a>    <span class="kw">pub </span>old_end_byte: u32,
<a href=#114 id=114 data-nosnippet>114</a>    <span class="kw">pub </span>new_end_byte: u32,
<a href=#115 id=115 data-nosnippet>115</a>    <span class="kw">pub </span>start_point: TSPoint,
<a href=#116 id=116 data-nosnippet>116</a>    <span class="kw">pub </span>old_end_point: TSPoint,
<a href=#117 id=117 data-nosnippet>117</a>    <span class="kw">pub </span>new_end_point: TSPoint,
<a href=#118 id=118 data-nosnippet>118</a>}
<a href=#119 id=119 data-nosnippet>119</a><span class="attr">#[repr(C)]
<a href=#120 id=120 data-nosnippet>120</a>#[derive(Debug, Copy, Clone)]
<a href=#121 id=121 data-nosnippet>121</a></span><span class="kw">pub struct </span>TSNode {
<a href=#122 id=122 data-nosnippet>122</a>    <span class="kw">pub </span>context: [u32; <span class="number">4usize</span>],
<a href=#123 id=123 data-nosnippet>123</a>    <span class="kw">pub </span>id: <span class="kw-2">*const </span>::core::ffi::c_void,
<a href=#124 id=124 data-nosnippet>124</a>    <span class="kw">pub </span>tree: <span class="kw-2">*const </span>TSTree,
<a href=#125 id=125 data-nosnippet>125</a>}
<a href=#126 id=126 data-nosnippet>126</a><span class="attr">#[repr(C)]
<a href=#127 id=127 data-nosnippet>127</a>#[derive(Debug, Copy, Clone)]
<a href=#128 id=128 data-nosnippet>128</a></span><span class="kw">pub struct </span>TSTreeCursor {
<a href=#129 id=129 data-nosnippet>129</a>    <span class="kw">pub </span>tree: <span class="kw-2">*const </span>::core::ffi::c_void,
<a href=#130 id=130 data-nosnippet>130</a>    <span class="kw">pub </span>id: <span class="kw-2">*const </span>::core::ffi::c_void,
<a href=#131 id=131 data-nosnippet>131</a>    <span class="kw">pub </span>context: [u32; <span class="number">3usize</span>],
<a href=#132 id=132 data-nosnippet>132</a>}
<a href=#133 id=133 data-nosnippet>133</a><span class="attr">#[repr(C)]
<a href=#134 id=134 data-nosnippet>134</a>#[derive(Debug)]
<a href=#135 id=135 data-nosnippet>135</a></span><span class="kw">pub struct </span>TSQueryCapture {
<a href=#136 id=136 data-nosnippet>136</a>    <span class="kw">pub </span>node: TSNode,
<a href=#137 id=137 data-nosnippet>137</a>    <span class="kw">pub </span>index: u32,
<a href=#138 id=138 data-nosnippet>138</a>}
<a href=#139 id=139 data-nosnippet>139</a><span class="kw">pub const </span>TSQuantifierZero: TSQuantifier = <span class="number">0</span>;
<a href=#140 id=140 data-nosnippet>140</a><span class="kw">pub const </span>TSQuantifierZeroOrOne: TSQuantifier = <span class="number">1</span>;
<a href=#141 id=141 data-nosnippet>141</a><span class="kw">pub const </span>TSQuantifierZeroOrMore: TSQuantifier = <span class="number">2</span>;
<a href=#142 id=142 data-nosnippet>142</a><span class="kw">pub const </span>TSQuantifierOne: TSQuantifier = <span class="number">3</span>;
<a href=#143 id=143 data-nosnippet>143</a><span class="kw">pub const </span>TSQuantifierOneOrMore: TSQuantifier = <span class="number">4</span>;
<a href=#144 id=144 data-nosnippet>144</a><span class="kw">pub type </span>TSQuantifier = ::core::ffi::c_uint;
<a href=#145 id=145 data-nosnippet>145</a><span class="attr">#[repr(C)]
<a href=#146 id=146 data-nosnippet>146</a>#[derive(Debug)]
<a href=#147 id=147 data-nosnippet>147</a></span><span class="kw">pub struct </span>TSQueryMatch {
<a href=#148 id=148 data-nosnippet>148</a>    <span class="kw">pub </span>id: u32,
<a href=#149 id=149 data-nosnippet>149</a>    <span class="kw">pub </span>pattern_index: u16,
<a href=#150 id=150 data-nosnippet>150</a>    <span class="kw">pub </span>capture_count: u16,
<a href=#151 id=151 data-nosnippet>151</a>    <span class="kw">pub </span>captures: <span class="kw-2">*const </span>TSQueryCapture,
<a href=#152 id=152 data-nosnippet>152</a>}
<a href=#153 id=153 data-nosnippet>153</a><span class="kw">pub const </span>TSQueryPredicateStepTypeDone: TSQueryPredicateStepType = <span class="number">0</span>;
<a href=#154 id=154 data-nosnippet>154</a><span class="kw">pub const </span>TSQueryPredicateStepTypeCapture: TSQueryPredicateStepType = <span class="number">1</span>;
<a href=#155 id=155 data-nosnippet>155</a><span class="kw">pub const </span>TSQueryPredicateStepTypeString: TSQueryPredicateStepType = <span class="number">2</span>;
<a href=#156 id=156 data-nosnippet>156</a><span class="kw">pub type </span>TSQueryPredicateStepType = ::core::ffi::c_uint;
<a href=#157 id=157 data-nosnippet>157</a><span class="attr">#[repr(C)]
<a href=#158 id=158 data-nosnippet>158</a>#[derive(Debug)]
<a href=#159 id=159 data-nosnippet>159</a></span><span class="kw">pub struct </span>TSQueryPredicateStep {
<a href=#160 id=160 data-nosnippet>160</a>    <span class="kw">pub </span>type_: TSQueryPredicateStepType,
<a href=#161 id=161 data-nosnippet>161</a>    <span class="kw">pub </span>value_id: u32,
<a href=#162 id=162 data-nosnippet>162</a>}
<a href=#163 id=163 data-nosnippet>163</a><span class="kw">pub const </span>TSQueryErrorNone: TSQueryError = <span class="number">0</span>;
<a href=#164 id=164 data-nosnippet>164</a><span class="kw">pub const </span>TSQueryErrorSyntax: TSQueryError = <span class="number">1</span>;
<a href=#165 id=165 data-nosnippet>165</a><span class="kw">pub const </span>TSQueryErrorNodeType: TSQueryError = <span class="number">2</span>;
<a href=#166 id=166 data-nosnippet>166</a><span class="kw">pub const </span>TSQueryErrorField: TSQueryError = <span class="number">3</span>;
<a href=#167 id=167 data-nosnippet>167</a><span class="kw">pub const </span>TSQueryErrorCapture: TSQueryError = <span class="number">4</span>;
<a href=#168 id=168 data-nosnippet>168</a><span class="kw">pub const </span>TSQueryErrorStructure: TSQueryError = <span class="number">5</span>;
<a href=#169 id=169 data-nosnippet>169</a><span class="kw">pub const </span>TSQueryErrorLanguage: TSQueryError = <span class="number">6</span>;
<a href=#170 id=170 data-nosnippet>170</a><span class="kw">pub type </span>TSQueryError = ::core::ffi::c_uint;
<a href=#171 id=171 data-nosnippet>171</a><span class="attr">#[repr(C)]
<a href=#172 id=172 data-nosnippet>172</a>#[derive(Debug, Copy, Clone)]
<a href=#173 id=173 data-nosnippet>173</a></span><span class="kw">pub struct </span>TSQueryCursorState {
<a href=#174 id=174 data-nosnippet>174</a>    <span class="kw">pub </span>payload: <span class="kw-2">*mut </span>::core::ffi::c_void,
<a href=#175 id=175 data-nosnippet>175</a>    <span class="kw">pub </span>current_byte_offset: u32,
<a href=#176 id=176 data-nosnippet>176</a>}
<a href=#177 id=177 data-nosnippet>177</a><span class="attr">#[repr(C)]
<a href=#178 id=178 data-nosnippet>178</a>#[derive(Debug, Copy, Clone)]
<a href=#179 id=179 data-nosnippet>179</a></span><span class="kw">pub struct </span>TSQueryCursorOptions {
<a href=#180 id=180 data-nosnippet>180</a>    <span class="kw">pub </span>payload: <span class="kw-2">*mut </span>::core::ffi::c_void,
<a href=#181 id=181 data-nosnippet>181</a>    <span class="kw">pub </span>progress_callback:
<a href=#182 id=182 data-nosnippet>182</a>        ::core::option::Option&lt;<span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn</span>(state: <span class="kw-2">*mut </span>TSQueryCursorState) -&gt; bool&gt;,
<a href=#183 id=183 data-nosnippet>183</a>}
<a href=#184 id=184 data-nosnippet>184</a><span class="attr">#[doc = <span class="string">" The metadata associated with a language.\n\n Currently, this metadata can be used to check the [Semantic Version](https://semver.org/)\n of the language. This version information should be used to signal if a given parser might\n be incompatible with existing queries when upgrading between major versions, or minor versions\n if it's in zerover."</span>]
<a href=#185 id=185 data-nosnippet>185</a>#[repr(C)]
<a href=#186 id=186 data-nosnippet>186</a>#[derive(Debug, Copy, Clone)]
<a href=#187 id=187 data-nosnippet>187</a></span><span class="kw">pub struct </span>TSLanguageMetadata {
<a href=#188 id=188 data-nosnippet>188</a>    <span class="kw">pub </span>major_version: u8,
<a href=#189 id=189 data-nosnippet>189</a>    <span class="kw">pub </span>minor_version: u8,
<a href=#190 id=190 data-nosnippet>190</a>    <span class="kw">pub </span>patch_version: u8,
<a href=#191 id=191 data-nosnippet>191</a>}
<a href=#192 id=192 data-nosnippet>192</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#193 id=193 data-nosnippet>193</a>    <span class="attr">#[doc = <span class="string">" Create a new parser."</span>]
<a href=#194 id=194 data-nosnippet>194</a>    </span><span class="kw">pub fn </span>ts_parser_new() -&gt; <span class="kw-2">*mut </span>TSParser;
<a href=#195 id=195 data-nosnippet>195</a>}
<a href=#196 id=196 data-nosnippet>196</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#197 id=197 data-nosnippet>197</a>    <span class="attr">#[doc = <span class="string">" Delete the parser, freeing all of the memory that it used."</span>]
<a href=#198 id=198 data-nosnippet>198</a>    </span><span class="kw">pub fn </span>ts_parser_delete(self_: <span class="kw-2">*mut </span>TSParser);
<a href=#199 id=199 data-nosnippet>199</a>}
<a href=#200 id=200 data-nosnippet>200</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#201 id=201 data-nosnippet>201</a>    <span class="attr">#[doc = <span class="string">" Get the parser's current language."</span>]
<a href=#202 id=202 data-nosnippet>202</a>    </span><span class="kw">pub fn </span>ts_parser_language(self_: <span class="kw-2">*const </span>TSParser) -&gt; <span class="kw-2">*const </span>TSLanguage;
<a href=#203 id=203 data-nosnippet>203</a>}
<a href=#204 id=204 data-nosnippet>204</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#205 id=205 data-nosnippet>205</a>    <span class="attr">#[doc = <span class="string">" Set the language that the parser should use for parsing.\n\n Returns a boolean indicating whether or not the language was successfully\n assigned. True means assignment succeeded. False means there was a version\n mismatch: the language was generated with an incompatible version of the\n Tree-sitter CLI. Check the language's ABI version using [`ts_language_abi_version`]\n and compare it to this library's [`TREE_SITTER_LANGUAGE_VERSION`] and\n [`TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION`] constants."</span>]
<a href=#206 id=206 data-nosnippet>206</a>    </span><span class="kw">pub fn </span>ts_parser_set_language(self_: <span class="kw-2">*mut </span>TSParser, language: <span class="kw-2">*const </span>TSLanguage) -&gt; bool;
<a href=#207 id=207 data-nosnippet>207</a>}
<a href=#208 id=208 data-nosnippet>208</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#209 id=209 data-nosnippet>209</a>    <span class="attr">#[doc = <span class="string">" Set the ranges of text that the parser should include when parsing.\n\n By default, the parser will always include entire documents. This function\n allows you to parse only a *portion* of a document but still return a syntax\n tree whose ranges match up with the document as a whole. You can also pass\n multiple disjoint ranges.\n\n The second and third parameters specify the location and length of an array\n of ranges. The parser does *not* take ownership of these ranges; it copies\n the data, so it doesn't matter how these ranges are allocated.\n\n If `count` is zero, then the entire document will be parsed. Otherwise,\n the given ranges must be ordered from earliest to latest in the document,\n and they must not overlap. That is, the following must hold for all:\n\n `i &lt; count - 1`: `ranges[i].end_byte &lt;= ranges[i + 1].start_byte`\n\n If this requirement is not satisfied, the operation will fail, the ranges\n will not be assigned, and this function will return `false`. On success,\n this function returns `true`"</span>]
<a href=#210 id=210 data-nosnippet>210</a>    </span><span class="kw">pub fn </span>ts_parser_set_included_ranges(
<a href=#211 id=211 data-nosnippet>211</a>        self_: <span class="kw-2">*mut </span>TSParser,
<a href=#212 id=212 data-nosnippet>212</a>        ranges: <span class="kw-2">*const </span>TSRange,
<a href=#213 id=213 data-nosnippet>213</a>        count: u32,
<a href=#214 id=214 data-nosnippet>214</a>    ) -&gt; bool;
<a href=#215 id=215 data-nosnippet>215</a>}
<a href=#216 id=216 data-nosnippet>216</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#217 id=217 data-nosnippet>217</a>    <span class="attr">#[doc = <span class="string">" Get the ranges of text that the parser will include when parsing.\n\n The returned pointer is owned by the parser. The caller should not free it\n or write to it. The length of the array will be written to the given\n `count` pointer."</span>]
<a href=#218 id=218 data-nosnippet>218</a>    </span><span class="kw">pub fn </span>ts_parser_included_ranges(self_: <span class="kw-2">*const </span>TSParser, count: <span class="kw-2">*mut </span>u32) -&gt; <span class="kw-2">*const </span>TSRange;
<a href=#219 id=219 data-nosnippet>219</a>}
<a href=#220 id=220 data-nosnippet>220</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#221 id=221 data-nosnippet>221</a>    <span class="attr">#[doc = <span class="string">" Use the parser to parse some source code and create a syntax tree.\n\n If you are parsing this document for the first time, pass `NULL` for the\n `old_tree` parameter. Otherwise, if you have already parsed an earlier\n version of this document and the document has since been edited, pass the\n previous syntax tree so that the unchanged parts of it can be reused.\n This will save time and memory. For this to work correctly, you must have\n already edited the old syntax tree using the [`ts_tree_edit`] function in a\n way that exactly matches the source code changes.\n\n The [`TSInput`] parameter lets you specify how to read the text. It has the\n following three fields:\n 1. [`read`]: A function to retrieve a chunk of text at a given byte offset\n    and (row, column) position. The function should return a pointer to the\n    text and write its length to the [`bytes_read`] pointer. The parser does\n    not take ownership of this buffer; it just borrows it until it has\n    finished reading it. The function should write a zero value to the\n    [`bytes_read`] pointer to indicate the end of the document.\n 2. [`payload`]: An arbitrary pointer that will be passed to each invocation\n    of the [`read`] function.\n 3. [`encoding`]: An indication of how the text is encoded. Either\n    `TSInputEncodingUTF8` or `TSInputEncodingUTF16`.\n\n This function returns a syntax tree on success, and `NULL` on failure. There\n are four possible reasons for failure:\n 1. The parser does not have a language assigned. Check for this using the\n[`ts_parser_language`] function.\n 2. Parsing was cancelled due to a timeout that was set by an earlier call to\n    the [`ts_parser_set_timeout_micros`] function. You can resume parsing from\n    where the parser left out by calling [`ts_parser_parse`] again with the\n    same arguments. Or you can start parsing from scratch by first calling\n    [`ts_parser_reset`].\n 3. Parsing was cancelled using a cancellation flag that was set by an\n    earlier call to [`ts_parser_set_cancellation_flag`]. You can resume parsing\n    from where the parser left out by calling [`ts_parser_parse`] again with\n    the same arguments.\n 4. Parsing was cancelled due to the progress callback returning true. This callback\n    is passed in [`ts_parser_parse_with_options`] inside the [`TSParseOptions`] struct.\n\n [`read`]: TSInput::read\n [`payload`]: TSInput::payload\n [`encoding`]: TSInput::encoding\n [`bytes_read`]: TSInput::read"</span>]
<a href=#222 id=222 data-nosnippet>222</a>    </span><span class="kw">pub fn </span>ts_parser_parse(
<a href=#223 id=223 data-nosnippet>223</a>        self_: <span class="kw-2">*mut </span>TSParser,
<a href=#224 id=224 data-nosnippet>224</a>        old_tree: <span class="kw-2">*const </span>TSTree,
<a href=#225 id=225 data-nosnippet>225</a>        input: TSInput,
<a href=#226 id=226 data-nosnippet>226</a>    ) -&gt; <span class="kw-2">*mut </span>TSTree;
<a href=#227 id=227 data-nosnippet>227</a>}
<a href=#228 id=228 data-nosnippet>228</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#229 id=229 data-nosnippet>229</a>    <span class="attr">#[doc = <span class="string">" Use the parser to parse some source code and create a syntax tree, with some options.\n\n See [`ts_parser_parse`] for more details.\n\n See [`TSParseOptions`] for more details on the options."</span>]
<a href=#230 id=230 data-nosnippet>230</a>    </span><span class="kw">pub fn </span>ts_parser_parse_with_options(
<a href=#231 id=231 data-nosnippet>231</a>        self_: <span class="kw-2">*mut </span>TSParser,
<a href=#232 id=232 data-nosnippet>232</a>        old_tree: <span class="kw-2">*const </span>TSTree,
<a href=#233 id=233 data-nosnippet>233</a>        input: TSInput,
<a href=#234 id=234 data-nosnippet>234</a>        parse_options: TSParseOptions,
<a href=#235 id=235 data-nosnippet>235</a>    ) -&gt; <span class="kw-2">*mut </span>TSTree;
<a href=#236 id=236 data-nosnippet>236</a>}
<a href=#237 id=237 data-nosnippet>237</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#238 id=238 data-nosnippet>238</a>    <span class="attr">#[doc = <span class="string">" Use the parser to parse some source code stored in one contiguous buffer.\n The first two parameters are the same as in the [`ts_parser_parse`] function\n above. The second two parameters indicate the location of the buffer and its\n length in bytes."</span>]
<a href=#239 id=239 data-nosnippet>239</a>    </span><span class="kw">pub fn </span>ts_parser_parse_string(
<a href=#240 id=240 data-nosnippet>240</a>        self_: <span class="kw-2">*mut </span>TSParser,
<a href=#241 id=241 data-nosnippet>241</a>        old_tree: <span class="kw-2">*const </span>TSTree,
<a href=#242 id=242 data-nosnippet>242</a>        string: <span class="kw-2">*const </span>::core::ffi::c_char,
<a href=#243 id=243 data-nosnippet>243</a>        length: u32,
<a href=#244 id=244 data-nosnippet>244</a>    ) -&gt; <span class="kw-2">*mut </span>TSTree;
<a href=#245 id=245 data-nosnippet>245</a>}
<a href=#246 id=246 data-nosnippet>246</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#247 id=247 data-nosnippet>247</a>    <span class="attr">#[doc = <span class="string">" Use the parser to parse some source code stored in one contiguous buffer with\n a given encoding. The first four parameters work the same as in the\n [`ts_parser_parse_string`] method above. The final parameter indicates whether\n the text is encoded as UTF8 or UTF16."</span>]
<a href=#248 id=248 data-nosnippet>248</a>    </span><span class="kw">pub fn </span>ts_parser_parse_string_encoding(
<a href=#249 id=249 data-nosnippet>249</a>        self_: <span class="kw-2">*mut </span>TSParser,
<a href=#250 id=250 data-nosnippet>250</a>        old_tree: <span class="kw-2">*const </span>TSTree,
<a href=#251 id=251 data-nosnippet>251</a>        string: <span class="kw-2">*const </span>::core::ffi::c_char,
<a href=#252 id=252 data-nosnippet>252</a>        length: u32,
<a href=#253 id=253 data-nosnippet>253</a>        encoding: TSInputEncoding,
<a href=#254 id=254 data-nosnippet>254</a>    ) -&gt; <span class="kw-2">*mut </span>TSTree;
<a href=#255 id=255 data-nosnippet>255</a>}
<a href=#256 id=256 data-nosnippet>256</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#257 id=257 data-nosnippet>257</a>    <span class="attr">#[doc = <span class="string">" Instruct the parser to start the next parse from the beginning.\n\n If the parser previously failed because of a timeout or a cancellation, then\n by default, it will resume where it left off on the next call to\n [`ts_parser_parse`] or other parsing functions. If you don't want to resume,\n and instead intend to use this parser to parse some other document, you must\n call [`ts_parser_reset`] first."</span>]
<a href=#258 id=258 data-nosnippet>258</a>    </span><span class="kw">pub fn </span>ts_parser_reset(self_: <span class="kw-2">*mut </span>TSParser);
<a href=#259 id=259 data-nosnippet>259</a>}
<a href=#260 id=260 data-nosnippet>260</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#261 id=261 data-nosnippet>261</a>    <span class="attr">#[doc = <span class="string">" @deprecated use [`ts_parser_parse_with_options`] and pass in a callback instead, this will be removed in 0.26.\n\n Set the maximum duration in microseconds that parsing should be allowed to\n take before halting.\n\n If parsing takes longer than this, it will halt early, returning NULL.\n See [`ts_parser_parse`] for more information."</span>]
<a href=#262 id=262 data-nosnippet>262</a>    </span><span class="kw">pub fn </span>ts_parser_set_timeout_micros(self_: <span class="kw-2">*mut </span>TSParser, timeout_micros: u64);
<a href=#263 id=263 data-nosnippet>263</a>}
<a href=#264 id=264 data-nosnippet>264</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#265 id=265 data-nosnippet>265</a>    <span class="attr">#[doc = <span class="string">" @deprecated use [`ts_parser_parse_with_options`] and pass in a callback instead, this will be removed in 0.26.\n\n Get the duration in microseconds that parsing is allowed to take."</span>]
<a href=#266 id=266 data-nosnippet>266</a>    </span><span class="kw">pub fn </span>ts_parser_timeout_micros(self_: <span class="kw-2">*const </span>TSParser) -&gt; u64;
<a href=#267 id=267 data-nosnippet>267</a>}
<a href=#268 id=268 data-nosnippet>268</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#269 id=269 data-nosnippet>269</a>    <span class="attr">#[doc = <span class="string">" @deprecated use [`ts_parser_parse_with_options`] and pass in a callback instead, this will be removed in 0.26.\n\n Set the parser's current cancellation flag pointer.\n\n If a non-null pointer is assigned, then the parser will periodically read\n from this pointer during parsing. If it reads a non-zero value, it will\n halt early, returning NULL. See [`ts_parser_parse`] for more information."</span>]
<a href=#270 id=270 data-nosnippet>270</a>    </span><span class="kw">pub fn </span>ts_parser_set_cancellation_flag(self_: <span class="kw-2">*mut </span>TSParser, flag: <span class="kw-2">*const </span>usize);
<a href=#271 id=271 data-nosnippet>271</a>}
<a href=#272 id=272 data-nosnippet>272</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#273 id=273 data-nosnippet>273</a>    <span class="attr">#[doc = <span class="string">" @deprecated use [`ts_parser_parse_with_options`] and pass in a callback instead, this will be removed in 0.26.\n\n Get the parser's current cancellation flag pointer."</span>]
<a href=#274 id=274 data-nosnippet>274</a>    </span><span class="kw">pub fn </span>ts_parser_cancellation_flag(self_: <span class="kw-2">*const </span>TSParser) -&gt; <span class="kw-2">*const </span>usize;
<a href=#275 id=275 data-nosnippet>275</a>}
<a href=#276 id=276 data-nosnippet>276</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#277 id=277 data-nosnippet>277</a>    <span class="attr">#[doc = <span class="string">" Set the logger that a parser should use during parsing.\n\n The parser does not take ownership over the logger payload. If a logger was\n previously assigned, the caller is responsible for releasing any memory\n owned by the previous logger."</span>]
<a href=#278 id=278 data-nosnippet>278</a>    </span><span class="kw">pub fn </span>ts_parser_set_logger(self_: <span class="kw-2">*mut </span>TSParser, logger: TSLogger);
<a href=#279 id=279 data-nosnippet>279</a>}
<a href=#280 id=280 data-nosnippet>280</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#281 id=281 data-nosnippet>281</a>    <span class="attr">#[doc = <span class="string">" Get the parser's current logger."</span>]
<a href=#282 id=282 data-nosnippet>282</a>    </span><span class="kw">pub fn </span>ts_parser_logger(self_: <span class="kw-2">*const </span>TSParser) -&gt; TSLogger;
<a href=#283 id=283 data-nosnippet>283</a>}
<a href=#284 id=284 data-nosnippet>284</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#285 id=285 data-nosnippet>285</a>    <span class="attr">#[doc = <span class="string">" Set the file descriptor to which the parser should write debugging graphs\n during parsing. The graphs are formatted in the DOT language. You may want\n to pipe these graphs directly to a `dot(1)` process in order to generate\n SVG output. You can turn off this logging by passing a negative number."</span>]
<a href=#286 id=286 data-nosnippet>286</a>    </span><span class="kw">pub fn </span>ts_parser_print_dot_graphs(self_: <span class="kw-2">*mut </span>TSParser, fd: ::core::ffi::c_int);
<a href=#287 id=287 data-nosnippet>287</a>}
<a href=#288 id=288 data-nosnippet>288</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#289 id=289 data-nosnippet>289</a>    <span class="attr">#[doc = <span class="string">" Create a shallow copy of the syntax tree. This is very fast.\n\n You need to copy a syntax tree in order to use it on more than one thread at\n a time, as syntax trees are not thread safe."</span>]
<a href=#290 id=290 data-nosnippet>290</a>    </span><span class="kw">pub fn </span>ts_tree_copy(self_: <span class="kw-2">*const </span>TSTree) -&gt; <span class="kw-2">*mut </span>TSTree;
<a href=#291 id=291 data-nosnippet>291</a>}
<a href=#292 id=292 data-nosnippet>292</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#293 id=293 data-nosnippet>293</a>    <span class="attr">#[doc = <span class="string">" Delete the syntax tree, freeing all of the memory that it used."</span>]
<a href=#294 id=294 data-nosnippet>294</a>    </span><span class="kw">pub fn </span>ts_tree_delete(self_: <span class="kw-2">*mut </span>TSTree);
<a href=#295 id=295 data-nosnippet>295</a>}
<a href=#296 id=296 data-nosnippet>296</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#297 id=297 data-nosnippet>297</a>    <span class="attr">#[doc = <span class="string">" Get the root node of the syntax tree."</span>]
<a href=#298 id=298 data-nosnippet>298</a>    </span><span class="kw">pub fn </span>ts_tree_root_node(self_: <span class="kw-2">*const </span>TSTree) -&gt; TSNode;
<a href=#299 id=299 data-nosnippet>299</a>}
<a href=#300 id=300 data-nosnippet>300</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#301 id=301 data-nosnippet>301</a>    <span class="attr">#[doc = <span class="string">" Get the root node of the syntax tree, but with its position\n shifted forward by the given offset."</span>]
<a href=#302 id=302 data-nosnippet>302</a>    </span><span class="kw">pub fn </span>ts_tree_root_node_with_offset(
<a href=#303 id=303 data-nosnippet>303</a>        self_: <span class="kw-2">*const </span>TSTree,
<a href=#304 id=304 data-nosnippet>304</a>        offset_bytes: u32,
<a href=#305 id=305 data-nosnippet>305</a>        offset_extent: TSPoint,
<a href=#306 id=306 data-nosnippet>306</a>    ) -&gt; TSNode;
<a href=#307 id=307 data-nosnippet>307</a>}
<a href=#308 id=308 data-nosnippet>308</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#309 id=309 data-nosnippet>309</a>    <span class="attr">#[doc = <span class="string">" Get the language that was used to parse the syntax tree."</span>]
<a href=#310 id=310 data-nosnippet>310</a>    </span><span class="kw">pub fn </span>ts_tree_language(self_: <span class="kw-2">*const </span>TSTree) -&gt; <span class="kw-2">*const </span>TSLanguage;
<a href=#311 id=311 data-nosnippet>311</a>}
<a href=#312 id=312 data-nosnippet>312</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#313 id=313 data-nosnippet>313</a>    <span class="attr">#[doc = <span class="string">" Get the array of included ranges that was used to parse the syntax tree.\n\n The returned pointer must be freed by the caller."</span>]
<a href=#314 id=314 data-nosnippet>314</a>    </span><span class="kw">pub fn </span>ts_tree_included_ranges(self_: <span class="kw-2">*const </span>TSTree, length: <span class="kw-2">*mut </span>u32) -&gt; <span class="kw-2">*mut </span>TSRange;
<a href=#315 id=315 data-nosnippet>315</a>}
<a href=#316 id=316 data-nosnippet>316</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#317 id=317 data-nosnippet>317</a>    <span class="attr">#[doc = <span class="string">" Edit the syntax tree to keep it in sync with source code that has been\n edited.\n\n You must describe the edit both in terms of byte offsets and in terms of\n (row, column) coordinates."</span>]
<a href=#318 id=318 data-nosnippet>318</a>    </span><span class="kw">pub fn </span>ts_tree_edit(self_: <span class="kw-2">*mut </span>TSTree, edit: <span class="kw-2">*const </span>TSInputEdit);
<a href=#319 id=319 data-nosnippet>319</a>}
<a href=#320 id=320 data-nosnippet>320</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#321 id=321 data-nosnippet>321</a>    <span class="attr">#[doc = <span class="string">" Compare an old edited syntax tree to a new syntax tree representing the same\n document, returning an array of ranges whose syntactic structure has changed.\n\n For this to work correctly, the old syntax tree must have been edited such\n that its ranges match up to the new tree. Generally, you'll want to call\n this function right after calling one of the [`ts_parser_parse`] functions.\n You need to pass the old tree that was passed to parse, as well as the new\n tree that was returned from that function.\n\n The returned ranges indicate areas where the hierarchical structure of syntax\n nodes (from root to leaf) has changed between the old and new trees. Characters\n outside these ranges have identical ancestor nodes in both trees.\n\n Note that the returned ranges may be slightly larger than the exact changed areas,\n but Tree-sitter attempts to make them as small as possible.\n\n The returned array is allocated using `malloc` and the caller is responsible\n for freeing it using `free`. The length of the array will be written to the\n given `length` pointer."</span>]
<a href=#322 id=322 data-nosnippet>322</a>    </span><span class="kw">pub fn </span>ts_tree_get_changed_ranges(
<a href=#323 id=323 data-nosnippet>323</a>        old_tree: <span class="kw-2">*const </span>TSTree,
<a href=#324 id=324 data-nosnippet>324</a>        new_tree: <span class="kw-2">*const </span>TSTree,
<a href=#325 id=325 data-nosnippet>325</a>        length: <span class="kw-2">*mut </span>u32,
<a href=#326 id=326 data-nosnippet>326</a>    ) -&gt; <span class="kw-2">*mut </span>TSRange;
<a href=#327 id=327 data-nosnippet>327</a>}
<a href=#328 id=328 data-nosnippet>328</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#329 id=329 data-nosnippet>329</a>    <span class="attr">#[doc = <span class="string">" Write a DOT graph describing the syntax tree to the given file."</span>]
<a href=#330 id=330 data-nosnippet>330</a>    </span><span class="kw">pub fn </span>ts_tree_print_dot_graph(self_: <span class="kw-2">*const </span>TSTree, file_descriptor: ::core::ffi::c_int);
<a href=#331 id=331 data-nosnippet>331</a>}
<a href=#332 id=332 data-nosnippet>332</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#333 id=333 data-nosnippet>333</a>    <span class="attr">#[doc = <span class="string">" Get the node's type as a null-terminated string."</span>]
<a href=#334 id=334 data-nosnippet>334</a>    </span><span class="kw">pub fn </span>ts_node_type(self_: TSNode) -&gt; <span class="kw-2">*const </span>::core::ffi::c_char;
<a href=#335 id=335 data-nosnippet>335</a>}
<a href=#336 id=336 data-nosnippet>336</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#337 id=337 data-nosnippet>337</a>    <span class="attr">#[doc = <span class="string">" Get the node's type as a numerical id."</span>]
<a href=#338 id=338 data-nosnippet>338</a>    </span><span class="kw">pub fn </span>ts_node_symbol(self_: TSNode) -&gt; TSSymbol;
<a href=#339 id=339 data-nosnippet>339</a>}
<a href=#340 id=340 data-nosnippet>340</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#341 id=341 data-nosnippet>341</a>    <span class="attr">#[doc = <span class="string">" Get the node's language."</span>]
<a href=#342 id=342 data-nosnippet>342</a>    </span><span class="kw">pub fn </span>ts_node_language(self_: TSNode) -&gt; <span class="kw-2">*const </span>TSLanguage;
<a href=#343 id=343 data-nosnippet>343</a>}
<a href=#344 id=344 data-nosnippet>344</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#345 id=345 data-nosnippet>345</a>    <span class="attr">#[doc = <span class="string">" Get the node's type as it appears in the grammar ignoring aliases as a\n null-terminated string."</span>]
<a href=#346 id=346 data-nosnippet>346</a>    </span><span class="kw">pub fn </span>ts_node_grammar_type(self_: TSNode) -&gt; <span class="kw-2">*const </span>::core::ffi::c_char;
<a href=#347 id=347 data-nosnippet>347</a>}
<a href=#348 id=348 data-nosnippet>348</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#349 id=349 data-nosnippet>349</a>    <span class="attr">#[doc = <span class="string">" Get the node's type as a numerical id as it appears in the grammar ignoring\n aliases. This should be used in [`ts_language_next_state`] instead of\n [`ts_node_symbol`]."</span>]
<a href=#350 id=350 data-nosnippet>350</a>    </span><span class="kw">pub fn </span>ts_node_grammar_symbol(self_: TSNode) -&gt; TSSymbol;
<a href=#351 id=351 data-nosnippet>351</a>}
<a href=#352 id=352 data-nosnippet>352</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#353 id=353 data-nosnippet>353</a>    <span class="attr">#[doc = <span class="string">" Get the node's start byte."</span>]
<a href=#354 id=354 data-nosnippet>354</a>    </span><span class="kw">pub fn </span>ts_node_start_byte(self_: TSNode) -&gt; u32;
<a href=#355 id=355 data-nosnippet>355</a>}
<a href=#356 id=356 data-nosnippet>356</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#357 id=357 data-nosnippet>357</a>    <span class="attr">#[doc = <span class="string">" Get the node's start position in terms of rows and columns."</span>]
<a href=#358 id=358 data-nosnippet>358</a>    </span><span class="kw">pub fn </span>ts_node_start_point(self_: TSNode) -&gt; TSPoint;
<a href=#359 id=359 data-nosnippet>359</a>}
<a href=#360 id=360 data-nosnippet>360</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#361 id=361 data-nosnippet>361</a>    <span class="attr">#[doc = <span class="string">" Get the node's end byte."</span>]
<a href=#362 id=362 data-nosnippet>362</a>    </span><span class="kw">pub fn </span>ts_node_end_byte(self_: TSNode) -&gt; u32;
<a href=#363 id=363 data-nosnippet>363</a>}
<a href=#364 id=364 data-nosnippet>364</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#365 id=365 data-nosnippet>365</a>    <span class="attr">#[doc = <span class="string">" Get the node's end position in terms of rows and columns."</span>]
<a href=#366 id=366 data-nosnippet>366</a>    </span><span class="kw">pub fn </span>ts_node_end_point(self_: TSNode) -&gt; TSPoint;
<a href=#367 id=367 data-nosnippet>367</a>}
<a href=#368 id=368 data-nosnippet>368</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#369 id=369 data-nosnippet>369</a>    <span class="attr">#[doc = <span class="string">" Get an S-expression representing the node as a string.\n\n This string is allocated with `malloc` and the caller is responsible for\n freeing it using `free`."</span>]
<a href=#370 id=370 data-nosnippet>370</a>    </span><span class="kw">pub fn </span>ts_node_string(self_: TSNode) -&gt; <span class="kw-2">*mut </span>::core::ffi::c_char;
<a href=#371 id=371 data-nosnippet>371</a>}
<a href=#372 id=372 data-nosnippet>372</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#373 id=373 data-nosnippet>373</a>    <span class="attr">#[doc = <span class="string">" Check if the node is null. Functions like [`ts_node_child`] and\n [`ts_node_next_sibling`] will return a null node to indicate that no such node\n was found."</span>]
<a href=#374 id=374 data-nosnippet>374</a>    </span><span class="kw">pub fn </span>ts_node_is_null(self_: TSNode) -&gt; bool;
<a href=#375 id=375 data-nosnippet>375</a>}
<a href=#376 id=376 data-nosnippet>376</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#377 id=377 data-nosnippet>377</a>    <span class="attr">#[doc = <span class="string">" Check if the node is *named*. Named nodes correspond to named rules in the\n grammar, whereas *anonymous* nodes correspond to string literals in the\n grammar."</span>]
<a href=#378 id=378 data-nosnippet>378</a>    </span><span class="kw">pub fn </span>ts_node_is_named(self_: TSNode) -&gt; bool;
<a href=#379 id=379 data-nosnippet>379</a>}
<a href=#380 id=380 data-nosnippet>380</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#381 id=381 data-nosnippet>381</a>    <span class="attr">#[doc = <span class="string">" Check if the node is *missing*. Missing nodes are inserted by the parser in\n order to recover from certain kinds of syntax errors."</span>]
<a href=#382 id=382 data-nosnippet>382</a>    </span><span class="kw">pub fn </span>ts_node_is_missing(self_: TSNode) -&gt; bool;
<a href=#383 id=383 data-nosnippet>383</a>}
<a href=#384 id=384 data-nosnippet>384</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#385 id=385 data-nosnippet>385</a>    <span class="attr">#[doc = <span class="string">" Check if the node is *extra*. Extra nodes represent things like comments,\n which are not required the grammar, but can appear anywhere."</span>]
<a href=#386 id=386 data-nosnippet>386</a>    </span><span class="kw">pub fn </span>ts_node_is_extra(self_: TSNode) -&gt; bool;
<a href=#387 id=387 data-nosnippet>387</a>}
<a href=#388 id=388 data-nosnippet>388</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#389 id=389 data-nosnippet>389</a>    <span class="attr">#[doc = <span class="string">" Check if a syntax node has been edited."</span>]
<a href=#390 id=390 data-nosnippet>390</a>    </span><span class="kw">pub fn </span>ts_node_has_changes(self_: TSNode) -&gt; bool;
<a href=#391 id=391 data-nosnippet>391</a>}
<a href=#392 id=392 data-nosnippet>392</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#393 id=393 data-nosnippet>393</a>    <span class="attr">#[doc = <span class="string">" Check if the node is a syntax error or contains any syntax errors."</span>]
<a href=#394 id=394 data-nosnippet>394</a>    </span><span class="kw">pub fn </span>ts_node_has_error(self_: TSNode) -&gt; bool;
<a href=#395 id=395 data-nosnippet>395</a>}
<a href=#396 id=396 data-nosnippet>396</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#397 id=397 data-nosnippet>397</a>    <span class="attr">#[doc = <span class="string">" Check if the node is a syntax error."</span>]
<a href=#398 id=398 data-nosnippet>398</a>    </span><span class="kw">pub fn </span>ts_node_is_error(self_: TSNode) -&gt; bool;
<a href=#399 id=399 data-nosnippet>399</a>}
<a href=#400 id=400 data-nosnippet>400</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#401 id=401 data-nosnippet>401</a>    <span class="attr">#[doc = <span class="string">" Get this node's parse state."</span>]
<a href=#402 id=402 data-nosnippet>402</a>    </span><span class="kw">pub fn </span>ts_node_parse_state(self_: TSNode) -&gt; TSStateId;
<a href=#403 id=403 data-nosnippet>403</a>}
<a href=#404 id=404 data-nosnippet>404</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#405 id=405 data-nosnippet>405</a>    <span class="attr">#[doc = <span class="string">" Get the parse state after this node."</span>]
<a href=#406 id=406 data-nosnippet>406</a>    </span><span class="kw">pub fn </span>ts_node_next_parse_state(self_: TSNode) -&gt; TSStateId;
<a href=#407 id=407 data-nosnippet>407</a>}
<a href=#408 id=408 data-nosnippet>408</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#409 id=409 data-nosnippet>409</a>    <span class="attr">#[doc = <span class="string">" Get the node's immediate parent.\n Prefer [`ts_node_child_with_descendant`] for\n iterating over the node's ancestors."</span>]
<a href=#410 id=410 data-nosnippet>410</a>    </span><span class="kw">pub fn </span>ts_node_parent(self_: TSNode) -&gt; TSNode;
<a href=#411 id=411 data-nosnippet>411</a>}
<a href=#412 id=412 data-nosnippet>412</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#413 id=413 data-nosnippet>413</a>    <span class="attr">#[doc = <span class="string">" Get the node that contains `descendant`.\n\n Note that this can return `descendant` itself."</span>]
<a href=#414 id=414 data-nosnippet>414</a>    </span><span class="kw">pub fn </span>ts_node_child_with_descendant(self_: TSNode, descendant: TSNode) -&gt; TSNode;
<a href=#415 id=415 data-nosnippet>415</a>}
<a href=#416 id=416 data-nosnippet>416</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#417 id=417 data-nosnippet>417</a>    <span class="attr">#[doc = <span class="string">" Get the node's child at the given index, where zero represents the first\n child."</span>]
<a href=#418 id=418 data-nosnippet>418</a>    </span><span class="kw">pub fn </span>ts_node_child(self_: TSNode, child_index: u32) -&gt; TSNode;
<a href=#419 id=419 data-nosnippet>419</a>}
<a href=#420 id=420 data-nosnippet>420</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#421 id=421 data-nosnippet>421</a>    <span class="attr">#[doc = <span class="string">" Get the field name for node's child at the given index, where zero represents\n the first child. Returns NULL, if no field is found."</span>]
<a href=#422 id=422 data-nosnippet>422</a>    </span><span class="kw">pub fn </span>ts_node_field_name_for_child(
<a href=#423 id=423 data-nosnippet>423</a>        self_: TSNode,
<a href=#424 id=424 data-nosnippet>424</a>        child_index: u32,
<a href=#425 id=425 data-nosnippet>425</a>    ) -&gt; <span class="kw-2">*const </span>::core::ffi::c_char;
<a href=#426 id=426 data-nosnippet>426</a>}
<a href=#427 id=427 data-nosnippet>427</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#428 id=428 data-nosnippet>428</a>    <span class="attr">#[doc = <span class="string">" Get the field name for node's named child at the given index, where zero\n represents the first named child. Returns NULL, if no field is found."</span>]
<a href=#429 id=429 data-nosnippet>429</a>    </span><span class="kw">pub fn </span>ts_node_field_name_for_named_child(
<a href=#430 id=430 data-nosnippet>430</a>        self_: TSNode,
<a href=#431 id=431 data-nosnippet>431</a>        named_child_index: u32,
<a href=#432 id=432 data-nosnippet>432</a>    ) -&gt; <span class="kw-2">*const </span>::core::ffi::c_char;
<a href=#433 id=433 data-nosnippet>433</a>}
<a href=#434 id=434 data-nosnippet>434</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#435 id=435 data-nosnippet>435</a>    <span class="attr">#[doc = <span class="string">" Get the node's number of children."</span>]
<a href=#436 id=436 data-nosnippet>436</a>    </span><span class="kw">pub fn </span>ts_node_child_count(self_: TSNode) -&gt; u32;
<a href=#437 id=437 data-nosnippet>437</a>}
<a href=#438 id=438 data-nosnippet>438</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#439 id=439 data-nosnippet>439</a>    <span class="attr">#[doc = <span class="string">" Get the node's *named* child at the given index.\n\n See also [`ts_node_is_named`]."</span>]
<a href=#440 id=440 data-nosnippet>440</a>    </span><span class="kw">pub fn </span>ts_node_named_child(self_: TSNode, child_index: u32) -&gt; TSNode;
<a href=#441 id=441 data-nosnippet>441</a>}
<a href=#442 id=442 data-nosnippet>442</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#443 id=443 data-nosnippet>443</a>    <span class="attr">#[doc = <span class="string">" Get the node's number of *named* children.\n\n See also [`ts_node_is_named`]."</span>]
<a href=#444 id=444 data-nosnippet>444</a>    </span><span class="kw">pub fn </span>ts_node_named_child_count(self_: TSNode) -&gt; u32;
<a href=#445 id=445 data-nosnippet>445</a>}
<a href=#446 id=446 data-nosnippet>446</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#447 id=447 data-nosnippet>447</a>    <span class="attr">#[doc = <span class="string">" Get the node's child with the given field name."</span>]
<a href=#448 id=448 data-nosnippet>448</a>    </span><span class="kw">pub fn </span>ts_node_child_by_field_name(
<a href=#449 id=449 data-nosnippet>449</a>        self_: TSNode,
<a href=#450 id=450 data-nosnippet>450</a>        name: <span class="kw-2">*const </span>::core::ffi::c_char,
<a href=#451 id=451 data-nosnippet>451</a>        name_length: u32,
<a href=#452 id=452 data-nosnippet>452</a>    ) -&gt; TSNode;
<a href=#453 id=453 data-nosnippet>453</a>}
<a href=#454 id=454 data-nosnippet>454</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#455 id=455 data-nosnippet>455</a>    <span class="attr">#[doc = <span class="string">" Get the node's child with the given numerical field id.\n\n You can convert a field name to an id using the\n [`ts_language_field_id_for_name`] function."</span>]
<a href=#456 id=456 data-nosnippet>456</a>    </span><span class="kw">pub fn </span>ts_node_child_by_field_id(self_: TSNode, field_id: TSFieldId) -&gt; TSNode;
<a href=#457 id=457 data-nosnippet>457</a>}
<a href=#458 id=458 data-nosnippet>458</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#459 id=459 data-nosnippet>459</a>    <span class="attr">#[doc = <span class="string">" Get the node's next / previous sibling."</span>]
<a href=#460 id=460 data-nosnippet>460</a>    </span><span class="kw">pub fn </span>ts_node_next_sibling(self_: TSNode) -&gt; TSNode;
<a href=#461 id=461 data-nosnippet>461</a>}
<a href=#462 id=462 data-nosnippet>462</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#463 id=463 data-nosnippet>463</a>    <span class="kw">pub fn </span>ts_node_prev_sibling(self_: TSNode) -&gt; TSNode;
<a href=#464 id=464 data-nosnippet>464</a>}
<a href=#465 id=465 data-nosnippet>465</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#466 id=466 data-nosnippet>466</a>    <span class="attr">#[doc = <span class="string">" Get the node's next / previous *named* sibling."</span>]
<a href=#467 id=467 data-nosnippet>467</a>    </span><span class="kw">pub fn </span>ts_node_next_named_sibling(self_: TSNode) -&gt; TSNode;
<a href=#468 id=468 data-nosnippet>468</a>}
<a href=#469 id=469 data-nosnippet>469</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#470 id=470 data-nosnippet>470</a>    <span class="kw">pub fn </span>ts_node_prev_named_sibling(self_: TSNode) -&gt; TSNode;
<a href=#471 id=471 data-nosnippet>471</a>}
<a href=#472 id=472 data-nosnippet>472</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#473 id=473 data-nosnippet>473</a>    <span class="attr">#[doc = <span class="string">" Get the node's first child that contains or starts after the given byte offset."</span>]
<a href=#474 id=474 data-nosnippet>474</a>    </span><span class="kw">pub fn </span>ts_node_first_child_for_byte(self_: TSNode, byte: u32) -&gt; TSNode;
<a href=#475 id=475 data-nosnippet>475</a>}
<a href=#476 id=476 data-nosnippet>476</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#477 id=477 data-nosnippet>477</a>    <span class="attr">#[doc = <span class="string">" Get the node's first named child that contains or starts after the given byte offset."</span>]
<a href=#478 id=478 data-nosnippet>478</a>    </span><span class="kw">pub fn </span>ts_node_first_named_child_for_byte(self_: TSNode, byte: u32) -&gt; TSNode;
<a href=#479 id=479 data-nosnippet>479</a>}
<a href=#480 id=480 data-nosnippet>480</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#481 id=481 data-nosnippet>481</a>    <span class="attr">#[doc = <span class="string">" Get the node's number of descendants, including one for the node itself."</span>]
<a href=#482 id=482 data-nosnippet>482</a>    </span><span class="kw">pub fn </span>ts_node_descendant_count(self_: TSNode) -&gt; u32;
<a href=#483 id=483 data-nosnippet>483</a>}
<a href=#484 id=484 data-nosnippet>484</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#485 id=485 data-nosnippet>485</a>    <span class="attr">#[doc = <span class="string">" Get the smallest node within this node that spans the given range of bytes\n or (row, column) positions."</span>]
<a href=#486 id=486 data-nosnippet>486</a>    </span><span class="kw">pub fn </span>ts_node_descendant_for_byte_range(self_: TSNode, start: u32, end: u32) -&gt; TSNode;
<a href=#487 id=487 data-nosnippet>487</a>}
<a href=#488 id=488 data-nosnippet>488</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#489 id=489 data-nosnippet>489</a>    <span class="kw">pub fn </span>ts_node_descendant_for_point_range(
<a href=#490 id=490 data-nosnippet>490</a>        self_: TSNode,
<a href=#491 id=491 data-nosnippet>491</a>        start: TSPoint,
<a href=#492 id=492 data-nosnippet>492</a>        end: TSPoint,
<a href=#493 id=493 data-nosnippet>493</a>    ) -&gt; TSNode;
<a href=#494 id=494 data-nosnippet>494</a>}
<a href=#495 id=495 data-nosnippet>495</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#496 id=496 data-nosnippet>496</a>    <span class="attr">#[doc = <span class="string">" Get the smallest named node within this node that spans the given range of\n bytes or (row, column) positions."</span>]
<a href=#497 id=497 data-nosnippet>497</a>    </span><span class="kw">pub fn </span>ts_node_named_descendant_for_byte_range(self_: TSNode, start: u32, end: u32) -&gt; TSNode;
<a href=#498 id=498 data-nosnippet>498</a>}
<a href=#499 id=499 data-nosnippet>499</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#500 id=500 data-nosnippet>500</a>    <span class="kw">pub fn </span>ts_node_named_descendant_for_point_range(
<a href=#501 id=501 data-nosnippet>501</a>        self_: TSNode,
<a href=#502 id=502 data-nosnippet>502</a>        start: TSPoint,
<a href=#503 id=503 data-nosnippet>503</a>        end: TSPoint,
<a href=#504 id=504 data-nosnippet>504</a>    ) -&gt; TSNode;
<a href=#505 id=505 data-nosnippet>505</a>}
<a href=#506 id=506 data-nosnippet>506</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#507 id=507 data-nosnippet>507</a>    <span class="attr">#[doc = <span class="string">" Edit the node to keep it in-sync with source code that has been edited.\n\n This function is only rarely needed. When you edit a syntax tree with the\n [`ts_tree_edit`] function, all of the nodes that you retrieve from the tree\n afterward will already reflect the edit. You only need to use [`ts_node_edit`]\n when you have a [`TSNode`] instance that you want to keep and continue to use\n after an edit."</span>]
<a href=#508 id=508 data-nosnippet>508</a>    </span><span class="kw">pub fn </span>ts_node_edit(self_: <span class="kw-2">*mut </span>TSNode, edit: <span class="kw-2">*const </span>TSInputEdit);
<a href=#509 id=509 data-nosnippet>509</a>}
<a href=#510 id=510 data-nosnippet>510</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#511 id=511 data-nosnippet>511</a>    <span class="attr">#[doc = <span class="string">" Check if two nodes are identical."</span>]
<a href=#512 id=512 data-nosnippet>512</a>    </span><span class="kw">pub fn </span>ts_node_eq(self_: TSNode, other: TSNode) -&gt; bool;
<a href=#513 id=513 data-nosnippet>513</a>}
<a href=#514 id=514 data-nosnippet>514</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#515 id=515 data-nosnippet>515</a>    <span class="attr">#[doc = <span class="string">" Create a new tree cursor starting from the given node.\n\n A tree cursor allows you to walk a syntax tree more efficiently than is\n possible using the [`TSNode`] functions. It is a mutable object that is always\n on a certain syntax node, and can be moved imperatively to different nodes.\n\n Note that the given node is considered the root of the cursor,\n and the cursor cannot walk outside this node."</span>]
<a href=#516 id=516 data-nosnippet>516</a>    </span><span class="kw">pub fn </span>ts_tree_cursor_new(node: TSNode) -&gt; TSTreeCursor;
<a href=#517 id=517 data-nosnippet>517</a>}
<a href=#518 id=518 data-nosnippet>518</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#519 id=519 data-nosnippet>519</a>    <span class="attr">#[doc = <span class="string">" Delete a tree cursor, freeing all of the memory that it used."</span>]
<a href=#520 id=520 data-nosnippet>520</a>    </span><span class="kw">pub fn </span>ts_tree_cursor_delete(self_: <span class="kw-2">*mut </span>TSTreeCursor);
<a href=#521 id=521 data-nosnippet>521</a>}
<a href=#522 id=522 data-nosnippet>522</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#523 id=523 data-nosnippet>523</a>    <span class="attr">#[doc = <span class="string">" Re-initialize a tree cursor to start at the original node that the cursor was\n constructed with."</span>]
<a href=#524 id=524 data-nosnippet>524</a>    </span><span class="kw">pub fn </span>ts_tree_cursor_reset(self_: <span class="kw-2">*mut </span>TSTreeCursor, node: TSNode);
<a href=#525 id=525 data-nosnippet>525</a>}
<a href=#526 id=526 data-nosnippet>526</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#527 id=527 data-nosnippet>527</a>    <span class="attr">#[doc = <span class="string">" Re-initialize a tree cursor to the same position as another cursor.\n\n Unlike [`ts_tree_cursor_reset`], this will not lose parent information and\n allows reusing already created cursors."</span>]
<a href=#528 id=528 data-nosnippet>528</a>    </span><span class="kw">pub fn </span>ts_tree_cursor_reset_to(dst: <span class="kw-2">*mut </span>TSTreeCursor, src: <span class="kw-2">*const </span>TSTreeCursor);
<a href=#529 id=529 data-nosnippet>529</a>}
<a href=#530 id=530 data-nosnippet>530</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#531 id=531 data-nosnippet>531</a>    <span class="attr">#[doc = <span class="string">" Get the tree cursor's current node."</span>]
<a href=#532 id=532 data-nosnippet>532</a>    </span><span class="kw">pub fn </span>ts_tree_cursor_current_node(self_: <span class="kw-2">*const </span>TSTreeCursor) -&gt; TSNode;
<a href=#533 id=533 data-nosnippet>533</a>}
<a href=#534 id=534 data-nosnippet>534</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#535 id=535 data-nosnippet>535</a>    <span class="attr">#[doc = <span class="string">" Get the field name of the tree cursor's current node.\n\n This returns `NULL` if the current node doesn't have a field.\n See also [`ts_node_child_by_field_name`]."</span>]
<a href=#536 id=536 data-nosnippet>536</a>    </span><span class="kw">pub fn </span>ts_tree_cursor_current_field_name(
<a href=#537 id=537 data-nosnippet>537</a>        self_: <span class="kw-2">*const </span>TSTreeCursor,
<a href=#538 id=538 data-nosnippet>538</a>    ) -&gt; <span class="kw-2">*const </span>::core::ffi::c_char;
<a href=#539 id=539 data-nosnippet>539</a>}
<a href=#540 id=540 data-nosnippet>540</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#541 id=541 data-nosnippet>541</a>    <span class="attr">#[doc = <span class="string">" Get the field id of the tree cursor's current node.\n\n This returns zero if the current node doesn't have a field.\n See also [`ts_node_child_by_field_id`], [`ts_language_field_id_for_name`]."</span>]
<a href=#542 id=542 data-nosnippet>542</a>    </span><span class="kw">pub fn </span>ts_tree_cursor_current_field_id(self_: <span class="kw-2">*const </span>TSTreeCursor) -&gt; TSFieldId;
<a href=#543 id=543 data-nosnippet>543</a>}
<a href=#544 id=544 data-nosnippet>544</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#545 id=545 data-nosnippet>545</a>    <span class="attr">#[doc = <span class="string">" Move the cursor to the parent of its current node.\n\n This returns `true` if the cursor successfully moved, and returns `false`\n if there was no parent node (the cursor was already on the root node).\n\n Note that the node the cursor was constructed with is considered the root\n of the cursor, and the cursor cannot walk outside this node."</span>]
<a href=#546 id=546 data-nosnippet>546</a>    </span><span class="kw">pub fn </span>ts_tree_cursor_goto_parent(self_: <span class="kw-2">*mut </span>TSTreeCursor) -&gt; bool;
<a href=#547 id=547 data-nosnippet>547</a>}
<a href=#548 id=548 data-nosnippet>548</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#549 id=549 data-nosnippet>549</a>    <span class="attr">#[doc = <span class="string">" Move the cursor to the next sibling of its current node.\n\n This returns `true` if the cursor successfully moved, and returns `false`\n if there was no next sibling node.\n\n Note that the node the cursor was constructed with is considered the root\n of the cursor, and the cursor cannot walk outside this node."</span>]
<a href=#550 id=550 data-nosnippet>550</a>    </span><span class="kw">pub fn </span>ts_tree_cursor_goto_next_sibling(self_: <span class="kw-2">*mut </span>TSTreeCursor) -&gt; bool;
<a href=#551 id=551 data-nosnippet>551</a>}
<a href=#552 id=552 data-nosnippet>552</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#553 id=553 data-nosnippet>553</a>    <span class="attr">#[doc = <span class="string">" Move the cursor to the previous sibling of its current node.\n\n This returns `true` if the cursor successfully moved, and returns `false` if\n there was no previous sibling node.\n\n Note, that this function may be slower than\n [`ts_tree_cursor_goto_next_sibling`] due to how node positions are stored. In\n the worst case, this will need to iterate through all the children up to the\n previous sibling node to recalculate its position. Also note that the node the cursor\n was constructed with is considered the root of the cursor, and the cursor cannot\n walk outside this node."</span>]
<a href=#554 id=554 data-nosnippet>554</a>    </span><span class="kw">pub fn </span>ts_tree_cursor_goto_previous_sibling(self_: <span class="kw-2">*mut </span>TSTreeCursor) -&gt; bool;
<a href=#555 id=555 data-nosnippet>555</a>}
<a href=#556 id=556 data-nosnippet>556</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#557 id=557 data-nosnippet>557</a>    <span class="attr">#[doc = <span class="string">" Move the cursor to the first child of its current node.\n\n This returns `true` if the cursor successfully moved, and returns `false`\n if there were no children."</span>]
<a href=#558 id=558 data-nosnippet>558</a>    </span><span class="kw">pub fn </span>ts_tree_cursor_goto_first_child(self_: <span class="kw-2">*mut </span>TSTreeCursor) -&gt; bool;
<a href=#559 id=559 data-nosnippet>559</a>}
<a href=#560 id=560 data-nosnippet>560</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#561 id=561 data-nosnippet>561</a>    <span class="attr">#[doc = <span class="string">" Move the cursor to the last child of its current node.\n\n This returns `true` if the cursor successfully moved, and returns `false` if\n there were no children.\n\n Note that this function may be slower than [`ts_tree_cursor_goto_first_child`]\n because it needs to iterate through all the children to compute the child's\n position."</span>]
<a href=#562 id=562 data-nosnippet>562</a>    </span><span class="kw">pub fn </span>ts_tree_cursor_goto_last_child(self_: <span class="kw-2">*mut </span>TSTreeCursor) -&gt; bool;
<a href=#563 id=563 data-nosnippet>563</a>}
<a href=#564 id=564 data-nosnippet>564</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#565 id=565 data-nosnippet>565</a>    <span class="attr">#[doc = <span class="string">" Move the cursor to the node that is the nth descendant of\n the original node that the cursor was constructed with, where\n zero represents the original node itself."</span>]
<a href=#566 id=566 data-nosnippet>566</a>    </span><span class="kw">pub fn </span>ts_tree_cursor_goto_descendant(self_: <span class="kw-2">*mut </span>TSTreeCursor, goal_descendant_index: u32);
<a href=#567 id=567 data-nosnippet>567</a>}
<a href=#568 id=568 data-nosnippet>568</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#569 id=569 data-nosnippet>569</a>    <span class="attr">#[doc = <span class="string">" Get the index of the cursor's current node out of all of the\n descendants of the original node that the cursor was constructed with."</span>]
<a href=#570 id=570 data-nosnippet>570</a>    </span><span class="kw">pub fn </span>ts_tree_cursor_current_descendant_index(self_: <span class="kw-2">*const </span>TSTreeCursor) -&gt; u32;
<a href=#571 id=571 data-nosnippet>571</a>}
<a href=#572 id=572 data-nosnippet>572</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#573 id=573 data-nosnippet>573</a>    <span class="attr">#[doc = <span class="string">" Get the depth of the cursor's current node relative to the original\n node that the cursor was constructed with."</span>]
<a href=#574 id=574 data-nosnippet>574</a>    </span><span class="kw">pub fn </span>ts_tree_cursor_current_depth(self_: <span class="kw-2">*const </span>TSTreeCursor) -&gt; u32;
<a href=#575 id=575 data-nosnippet>575</a>}
<a href=#576 id=576 data-nosnippet>576</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#577 id=577 data-nosnippet>577</a>    <span class="attr">#[doc = <span class="string">" Move the cursor to the first child of its current node that contains or starts after\n the given byte offset or point.\n\n This returns the index of the child node if one was found, and returns -1\n if no such child was found."</span>]
<a href=#578 id=578 data-nosnippet>578</a>    </span><span class="kw">pub fn </span>ts_tree_cursor_goto_first_child_for_byte(
<a href=#579 id=579 data-nosnippet>579</a>        self_: <span class="kw-2">*mut </span>TSTreeCursor,
<a href=#580 id=580 data-nosnippet>580</a>        goal_byte: u32,
<a href=#581 id=581 data-nosnippet>581</a>    ) -&gt; i64;
<a href=#582 id=582 data-nosnippet>582</a>}
<a href=#583 id=583 data-nosnippet>583</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#584 id=584 data-nosnippet>584</a>    <span class="kw">pub fn </span>ts_tree_cursor_goto_first_child_for_point(
<a href=#585 id=585 data-nosnippet>585</a>        self_: <span class="kw-2">*mut </span>TSTreeCursor,
<a href=#586 id=586 data-nosnippet>586</a>        goal_point: TSPoint,
<a href=#587 id=587 data-nosnippet>587</a>    ) -&gt; i64;
<a href=#588 id=588 data-nosnippet>588</a>}
<a href=#589 id=589 data-nosnippet>589</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#590 id=590 data-nosnippet>590</a>    <span class="kw">pub fn </span>ts_tree_cursor_copy(cursor: <span class="kw-2">*const </span>TSTreeCursor) -&gt; TSTreeCursor;
<a href=#591 id=591 data-nosnippet>591</a>}
<a href=#592 id=592 data-nosnippet>592</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#593 id=593 data-nosnippet>593</a>    <span class="attr">#[doc = <span class="string">" Create a new query from a string containing one or more S-expression\n patterns. The query is associated with a particular language, and can\n only be run on syntax nodes parsed with that language.\n\n If all of the given patterns are valid, this returns a [`TSQuery`].\n If a pattern is invalid, this returns `NULL`, and provides two pieces\n of information about the problem:\n 1. The byte offset of the error is written to the `error_offset` parameter.\n 2. The type of error is written to the `error_type` parameter."</span>]
<a href=#594 id=594 data-nosnippet>594</a>    </span><span class="kw">pub fn </span>ts_query_new(
<a href=#595 id=595 data-nosnippet>595</a>        language: <span class="kw-2">*const </span>TSLanguage,
<a href=#596 id=596 data-nosnippet>596</a>        source: <span class="kw-2">*const </span>::core::ffi::c_char,
<a href=#597 id=597 data-nosnippet>597</a>        source_len: u32,
<a href=#598 id=598 data-nosnippet>598</a>        error_offset: <span class="kw-2">*mut </span>u32,
<a href=#599 id=599 data-nosnippet>599</a>        error_type: <span class="kw-2">*mut </span>TSQueryError,
<a href=#600 id=600 data-nosnippet>600</a>    ) -&gt; <span class="kw-2">*mut </span>TSQuery;
<a href=#601 id=601 data-nosnippet>601</a>}
<a href=#602 id=602 data-nosnippet>602</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#603 id=603 data-nosnippet>603</a>    <span class="attr">#[doc = <span class="string">" Delete a query, freeing all of the memory that it used."</span>]
<a href=#604 id=604 data-nosnippet>604</a>    </span><span class="kw">pub fn </span>ts_query_delete(self_: <span class="kw-2">*mut </span>TSQuery);
<a href=#605 id=605 data-nosnippet>605</a>}
<a href=#606 id=606 data-nosnippet>606</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#607 id=607 data-nosnippet>607</a>    <span class="attr">#[doc = <span class="string">" Get the number of patterns, captures, or string literals in the query."</span>]
<a href=#608 id=608 data-nosnippet>608</a>    </span><span class="kw">pub fn </span>ts_query_pattern_count(self_: <span class="kw-2">*const </span>TSQuery) -&gt; u32;
<a href=#609 id=609 data-nosnippet>609</a>}
<a href=#610 id=610 data-nosnippet>610</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#611 id=611 data-nosnippet>611</a>    <span class="kw">pub fn </span>ts_query_capture_count(self_: <span class="kw-2">*const </span>TSQuery) -&gt; u32;
<a href=#612 id=612 data-nosnippet>612</a>}
<a href=#613 id=613 data-nosnippet>613</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#614 id=614 data-nosnippet>614</a>    <span class="kw">pub fn </span>ts_query_string_count(self_: <span class="kw-2">*const </span>TSQuery) -&gt; u32;
<a href=#615 id=615 data-nosnippet>615</a>}
<a href=#616 id=616 data-nosnippet>616</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#617 id=617 data-nosnippet>617</a>    <span class="attr">#[doc = <span class="string">" Get the byte offset where the given pattern starts in the query's source.\n\n This can be useful when combining queries by concatenating their source\n code strings."</span>]
<a href=#618 id=618 data-nosnippet>618</a>    </span><span class="kw">pub fn </span>ts_query_start_byte_for_pattern(self_: <span class="kw-2">*const </span>TSQuery, pattern_index: u32) -&gt; u32;
<a href=#619 id=619 data-nosnippet>619</a>}
<a href=#620 id=620 data-nosnippet>620</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#621 id=621 data-nosnippet>621</a>    <span class="attr">#[doc = <span class="string">" Get the byte offset where the given pattern ends in the query's source.\n\n This can be useful when combining queries by concatenating their source\n code strings."</span>]
<a href=#622 id=622 data-nosnippet>622</a>    </span><span class="kw">pub fn </span>ts_query_end_byte_for_pattern(self_: <span class="kw-2">*const </span>TSQuery, pattern_index: u32) -&gt; u32;
<a href=#623 id=623 data-nosnippet>623</a>}
<a href=#624 id=624 data-nosnippet>624</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#625 id=625 data-nosnippet>625</a>    <span class="attr">#[doc = <span class="string">" Get all of the predicates for the given pattern in the query.\n\n The predicates are represented as a single array of steps. There are three\n types of steps in this array, which correspond to the three legal values for\n the `type` field:\n - `TSQueryPredicateStepTypeCapture` - Steps with this type represent names\n    of captures. Their `value_id` can be used with the\n   [`ts_query_capture_name_for_id`] function to obtain the name of the capture.\n - `TSQueryPredicateStepTypeString` - Steps with this type represent literal\n    strings. Their `value_id` can be used with the\n    [`ts_query_string_value_for_id`] function to obtain their string value.\n - `TSQueryPredicateStepTypeDone` - Steps with this type are *sentinels*\n    that represent the end of an individual predicate. If a pattern has two\n    predicates, then there will be two steps with this `type` in the array."</span>]
<a href=#626 id=626 data-nosnippet>626</a>    </span><span class="kw">pub fn </span>ts_query_predicates_for_pattern(
<a href=#627 id=627 data-nosnippet>627</a>        self_: <span class="kw-2">*const </span>TSQuery,
<a href=#628 id=628 data-nosnippet>628</a>        pattern_index: u32,
<a href=#629 id=629 data-nosnippet>629</a>        step_count: <span class="kw-2">*mut </span>u32,
<a href=#630 id=630 data-nosnippet>630</a>    ) -&gt; <span class="kw-2">*const </span>TSQueryPredicateStep;
<a href=#631 id=631 data-nosnippet>631</a>}
<a href=#632 id=632 data-nosnippet>632</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#633 id=633 data-nosnippet>633</a>    <span class="kw">pub fn </span>ts_query_is_pattern_rooted(self_: <span class="kw-2">*const </span>TSQuery, pattern_index: u32) -&gt; bool;
<a href=#634 id=634 data-nosnippet>634</a>}
<a href=#635 id=635 data-nosnippet>635</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#636 id=636 data-nosnippet>636</a>    <span class="kw">pub fn </span>ts_query_is_pattern_non_local(self_: <span class="kw-2">*const </span>TSQuery, pattern_index: u32) -&gt; bool;
<a href=#637 id=637 data-nosnippet>637</a>}
<a href=#638 id=638 data-nosnippet>638</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#639 id=639 data-nosnippet>639</a>    <span class="kw">pub fn </span>ts_query_is_pattern_guaranteed_at_step(self_: <span class="kw-2">*const </span>TSQuery, byte_offset: u32) -&gt; bool;
<a href=#640 id=640 data-nosnippet>640</a>}
<a href=#641 id=641 data-nosnippet>641</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#642 id=642 data-nosnippet>642</a>    <span class="attr">#[doc = <span class="string">" Get the name and length of one of the query's captures, or one of the\n query's string literals. Each capture and string is associated with a\n numeric id based on the order that it appeared in the query's source."</span>]
<a href=#643 id=643 data-nosnippet>643</a>    </span><span class="kw">pub fn </span>ts_query_capture_name_for_id(
<a href=#644 id=644 data-nosnippet>644</a>        self_: <span class="kw-2">*const </span>TSQuery,
<a href=#645 id=645 data-nosnippet>645</a>        index: u32,
<a href=#646 id=646 data-nosnippet>646</a>        length: <span class="kw-2">*mut </span>u32,
<a href=#647 id=647 data-nosnippet>647</a>    ) -&gt; <span class="kw-2">*const </span>::core::ffi::c_char;
<a href=#648 id=648 data-nosnippet>648</a>}
<a href=#649 id=649 data-nosnippet>649</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#650 id=650 data-nosnippet>650</a>    <span class="attr">#[doc = <span class="string">" Get the quantifier of the query's captures. Each capture is * associated\n with a numeric id based on the order that it appeared in the query's source."</span>]
<a href=#651 id=651 data-nosnippet>651</a>    </span><span class="kw">pub fn </span>ts_query_capture_quantifier_for_id(
<a href=#652 id=652 data-nosnippet>652</a>        self_: <span class="kw-2">*const </span>TSQuery,
<a href=#653 id=653 data-nosnippet>653</a>        pattern_index: u32,
<a href=#654 id=654 data-nosnippet>654</a>        capture_index: u32,
<a href=#655 id=655 data-nosnippet>655</a>    ) -&gt; TSQuantifier;
<a href=#656 id=656 data-nosnippet>656</a>}
<a href=#657 id=657 data-nosnippet>657</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#658 id=658 data-nosnippet>658</a>    <span class="kw">pub fn </span>ts_query_string_value_for_id(
<a href=#659 id=659 data-nosnippet>659</a>        self_: <span class="kw-2">*const </span>TSQuery,
<a href=#660 id=660 data-nosnippet>660</a>        index: u32,
<a href=#661 id=661 data-nosnippet>661</a>        length: <span class="kw-2">*mut </span>u32,
<a href=#662 id=662 data-nosnippet>662</a>    ) -&gt; <span class="kw-2">*const </span>::core::ffi::c_char;
<a href=#663 id=663 data-nosnippet>663</a>}
<a href=#664 id=664 data-nosnippet>664</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#665 id=665 data-nosnippet>665</a>    <span class="attr">#[doc = <span class="string">" Disable a certain capture within a query.\n\n This prevents the capture from being returned in matches, and also avoids\n any resource usage associated with recording the capture. Currently, there\n is no way to undo this."</span>]
<a href=#666 id=666 data-nosnippet>666</a>    </span><span class="kw">pub fn </span>ts_query_disable_capture(
<a href=#667 id=667 data-nosnippet>667</a>        self_: <span class="kw-2">*mut </span>TSQuery,
<a href=#668 id=668 data-nosnippet>668</a>        name: <span class="kw-2">*const </span>::core::ffi::c_char,
<a href=#669 id=669 data-nosnippet>669</a>        length: u32,
<a href=#670 id=670 data-nosnippet>670</a>    );
<a href=#671 id=671 data-nosnippet>671</a>}
<a href=#672 id=672 data-nosnippet>672</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#673 id=673 data-nosnippet>673</a>    <span class="attr">#[doc = <span class="string">" Disable a certain pattern within a query.\n\n This prevents the pattern from matching and removes most of the overhead\n associated with the pattern. Currently, there is no way to undo this."</span>]
<a href=#674 id=674 data-nosnippet>674</a>    </span><span class="kw">pub fn </span>ts_query_disable_pattern(self_: <span class="kw-2">*mut </span>TSQuery, pattern_index: u32);
<a href=#675 id=675 data-nosnippet>675</a>}
<a href=#676 id=676 data-nosnippet>676</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#677 id=677 data-nosnippet>677</a>    <span class="attr">#[doc = <span class="string">" Create a new cursor for executing a given query.\n\n The cursor stores the state that is needed to iteratively search\n for matches. To use the query cursor, first call [`ts_query_cursor_exec`]\n to start running a given query on a given syntax node. Then, there are\n two options for consuming the results of the query:\n 1. Repeatedly call [`ts_query_cursor_next_match`] to iterate over all of the\n    *matches* in the order that they were found. Each match contains the\n    index of the pattern that matched, and an array of captures. Because\n    multiple patterns can match the same set of nodes, one match may contain\n    captures that appear *before* some of the captures from a previous match.\n 2. Repeatedly call [`ts_query_cursor_next_capture`] to iterate over all of the\n    individual *captures* in the order that they appear. This is useful if\n    don't care about which pattern matched, and just want a single ordered\n    sequence of captures.\n\n If you don't care about consuming all of the results, you can stop calling\n [`ts_query_cursor_next_match`] or [`ts_query_cursor_next_capture`] at any point.\n  You can then start executing another query on another node by calling\n  [`ts_query_cursor_exec`] again."</span>]
<a href=#678 id=678 data-nosnippet>678</a>    </span><span class="kw">pub fn </span>ts_query_cursor_new() -&gt; <span class="kw-2">*mut </span>TSQueryCursor;
<a href=#679 id=679 data-nosnippet>679</a>}
<a href=#680 id=680 data-nosnippet>680</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#681 id=681 data-nosnippet>681</a>    <span class="attr">#[doc = <span class="string">" Delete a query cursor, freeing all of the memory that it used."</span>]
<a href=#682 id=682 data-nosnippet>682</a>    </span><span class="kw">pub fn </span>ts_query_cursor_delete(self_: <span class="kw-2">*mut </span>TSQueryCursor);
<a href=#683 id=683 data-nosnippet>683</a>}
<a href=#684 id=684 data-nosnippet>684</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#685 id=685 data-nosnippet>685</a>    <span class="attr">#[doc = <span class="string">" Start running a given query on a given node."</span>]
<a href=#686 id=686 data-nosnippet>686</a>    </span><span class="kw">pub fn </span>ts_query_cursor_exec(self_: <span class="kw-2">*mut </span>TSQueryCursor, query: <span class="kw-2">*const </span>TSQuery, node: TSNode);
<a href=#687 id=687 data-nosnippet>687</a>}
<a href=#688 id=688 data-nosnippet>688</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#689 id=689 data-nosnippet>689</a>    <span class="attr">#[doc = <span class="string">" Start running a given query on a given node, with some options."</span>]
<a href=#690 id=690 data-nosnippet>690</a>    </span><span class="kw">pub fn </span>ts_query_cursor_exec_with_options(
<a href=#691 id=691 data-nosnippet>691</a>        self_: <span class="kw-2">*mut </span>TSQueryCursor,
<a href=#692 id=692 data-nosnippet>692</a>        query: <span class="kw-2">*const </span>TSQuery,
<a href=#693 id=693 data-nosnippet>693</a>        node: TSNode,
<a href=#694 id=694 data-nosnippet>694</a>        query_options: <span class="kw-2">*const </span>TSQueryCursorOptions,
<a href=#695 id=695 data-nosnippet>695</a>    );
<a href=#696 id=696 data-nosnippet>696</a>}
<a href=#697 id=697 data-nosnippet>697</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#698 id=698 data-nosnippet>698</a>    <span class="attr">#[doc = <span class="string">" Manage the maximum number of in-progress matches allowed by this query\n cursor.\n\n Query cursors have an optional maximum capacity for storing lists of\n in-progress captures. If this capacity is exceeded, then the\n earliest-starting match will silently be dropped to make room for further\n matches. This maximum capacity is optional  by default, query cursors allow\n any number of pending matches, dynamically allocating new space for them as\n needed as the query is executed."</span>]
<a href=#699 id=699 data-nosnippet>699</a>    </span><span class="kw">pub fn </span>ts_query_cursor_did_exceed_match_limit(self_: <span class="kw-2">*const </span>TSQueryCursor) -&gt; bool;
<a href=#700 id=700 data-nosnippet>700</a>}
<a href=#701 id=701 data-nosnippet>701</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#702 id=702 data-nosnippet>702</a>    <span class="kw">pub fn </span>ts_query_cursor_match_limit(self_: <span class="kw-2">*const </span>TSQueryCursor) -&gt; u32;
<a href=#703 id=703 data-nosnippet>703</a>}
<a href=#704 id=704 data-nosnippet>704</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#705 id=705 data-nosnippet>705</a>    <span class="kw">pub fn </span>ts_query_cursor_set_match_limit(self_: <span class="kw-2">*mut </span>TSQueryCursor, limit: u32);
<a href=#706 id=706 data-nosnippet>706</a>}
<a href=#707 id=707 data-nosnippet>707</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#708 id=708 data-nosnippet>708</a>    <span class="attr">#[doc = <span class="string">" @deprecated use [`ts_query_cursor_exec_with_options`] and pass in a callback instead, this will be removed in 0.26.\n\n Set the maximum duration in microseconds that query execution should be allowed to\n take before halting.\n\n If query execution takes longer than this, it will halt early, returning NULL.\n See [`ts_query_cursor_next_match`] or [`ts_query_cursor_next_capture`] for more information."</span>]
<a href=#709 id=709 data-nosnippet>709</a>    </span><span class="kw">pub fn </span>ts_query_cursor_set_timeout_micros(self_: <span class="kw-2">*mut </span>TSQueryCursor, timeout_micros: u64);
<a href=#710 id=710 data-nosnippet>710</a>}
<a href=#711 id=711 data-nosnippet>711</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#712 id=712 data-nosnippet>712</a>    <span class="attr">#[doc = <span class="string">" @deprecated use [`ts_query_cursor_exec_with_options`] and pass in a callback instead, this will be removed in 0.26.\n\n Get the duration in microseconds that query execution is allowed to take.\n\n This is set via [`ts_query_cursor_set_timeout_micros`]."</span>]
<a href=#713 id=713 data-nosnippet>713</a>    </span><span class="kw">pub fn </span>ts_query_cursor_timeout_micros(self_: <span class="kw-2">*const </span>TSQueryCursor) -&gt; u64;
<a href=#714 id=714 data-nosnippet>714</a>}
<a href=#715 id=715 data-nosnippet>715</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#716 id=716 data-nosnippet>716</a>    <span class="attr">#[doc = <span class="string">" Set the range of bytes in which the query will be executed.\n\n The query cursor will return matches that intersect with the given point range.\n This means that a match may be returned even if some of its captures fall\n outside the specified range, as long as at least part of the match\n overlaps with the range.\n\n For example, if a query pattern matches a node that spans a larger area\n than the specified range, but part of that node intersects with the range,\n the entire match will be returned.\n\n This will return `false` if the start byte is greater than the end byte, otherwise\n it will return `true`."</span>]
<a href=#717 id=717 data-nosnippet>717</a>    </span><span class="kw">pub fn </span>ts_query_cursor_set_byte_range(
<a href=#718 id=718 data-nosnippet>718</a>        self_: <span class="kw-2">*mut </span>TSQueryCursor,
<a href=#719 id=719 data-nosnippet>719</a>        start_byte: u32,
<a href=#720 id=720 data-nosnippet>720</a>        end_byte: u32,
<a href=#721 id=721 data-nosnippet>721</a>    ) -&gt; bool;
<a href=#722 id=722 data-nosnippet>722</a>}
<a href=#723 id=723 data-nosnippet>723</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#724 id=724 data-nosnippet>724</a>    <span class="attr">#[doc = <span class="string">" Set the range of (row, column) positions in which the query will be executed.\n\n The query cursor will return matches that intersect with the given point range.\n This means that a match may be returned even if some of its captures fall\n outside the specified range, as long as at least part of the match\n overlaps with the range.\n\n For example, if a query pattern matches a node that spans a larger area\n than the specified range, but part of that node intersects with the range,\n the entire match will be returned.\n\n This will return `false` if the start point is greater than the end point, otherwise\n it will return `true`."</span>]
<a href=#725 id=725 data-nosnippet>725</a>    </span><span class="kw">pub fn </span>ts_query_cursor_set_point_range(
<a href=#726 id=726 data-nosnippet>726</a>        self_: <span class="kw-2">*mut </span>TSQueryCursor,
<a href=#727 id=727 data-nosnippet>727</a>        start_point: TSPoint,
<a href=#728 id=728 data-nosnippet>728</a>        end_point: TSPoint,
<a href=#729 id=729 data-nosnippet>729</a>    ) -&gt; bool;
<a href=#730 id=730 data-nosnippet>730</a>}
<a href=#731 id=731 data-nosnippet>731</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#732 id=732 data-nosnippet>732</a>    <span class="attr">#[doc = <span class="string">" Advance to the next match of the currently running query.\n\n If there is a match, write it to `*match` and return `true`.\n Otherwise, return `false`."</span>]
<a href=#733 id=733 data-nosnippet>733</a>    </span><span class="kw">pub fn </span>ts_query_cursor_next_match(self_: <span class="kw-2">*mut </span>TSQueryCursor, match_: <span class="kw-2">*mut </span>TSQueryMatch)
<a href=#734 id=734 data-nosnippet>734</a>        -&gt; bool;
<a href=#735 id=735 data-nosnippet>735</a>}
<a href=#736 id=736 data-nosnippet>736</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#737 id=737 data-nosnippet>737</a>    <span class="kw">pub fn </span>ts_query_cursor_remove_match(self_: <span class="kw-2">*mut </span>TSQueryCursor, match_id: u32);
<a href=#738 id=738 data-nosnippet>738</a>}
<a href=#739 id=739 data-nosnippet>739</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#740 id=740 data-nosnippet>740</a>    <span class="attr">#[doc = <span class="string">" Advance to the next capture of the currently running query.\n\n If there is a capture, write its match to `*match` and its index within\n the match's capture list to `*capture_index`. Otherwise, return `false`."</span>]
<a href=#741 id=741 data-nosnippet>741</a>    </span><span class="kw">pub fn </span>ts_query_cursor_next_capture(
<a href=#742 id=742 data-nosnippet>742</a>        self_: <span class="kw-2">*mut </span>TSQueryCursor,
<a href=#743 id=743 data-nosnippet>743</a>        match_: <span class="kw-2">*mut </span>TSQueryMatch,
<a href=#744 id=744 data-nosnippet>744</a>        capture_index: <span class="kw-2">*mut </span>u32,
<a href=#745 id=745 data-nosnippet>745</a>    ) -&gt; bool;
<a href=#746 id=746 data-nosnippet>746</a>}
<a href=#747 id=747 data-nosnippet>747</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#748 id=748 data-nosnippet>748</a>    <span class="attr">#[doc = <span class="string">" Set the maximum start depth for a query cursor.\n\n This prevents cursors from exploring children nodes at a certain depth.\n Note if a pattern includes many children, then they will still be checked.\n\n The zero max start depth value can be used as a special behavior and\n it helps to destructure a subtree by staying on a node and using captures\n for interested parts. Note that the zero max start depth only limit a search\n depth for a pattern's root node but other nodes that are parts of the pattern\n may be searched at any depth what defined by the pattern structure.\n\n Set to `UINT32_MAX` to remove the maximum start depth."</span>]
<a href=#749 id=749 data-nosnippet>749</a>    </span><span class="kw">pub fn </span>ts_query_cursor_set_max_start_depth(self_: <span class="kw-2">*mut </span>TSQueryCursor, max_start_depth: u32);
<a href=#750 id=750 data-nosnippet>750</a>}
<a href=#751 id=751 data-nosnippet>751</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#752 id=752 data-nosnippet>752</a>    <span class="attr">#[doc = <span class="string">" Get another reference to the given language."</span>]
<a href=#753 id=753 data-nosnippet>753</a>    </span><span class="kw">pub fn </span>ts_language_copy(self_: <span class="kw-2">*const </span>TSLanguage) -&gt; <span class="kw-2">*const </span>TSLanguage;
<a href=#754 id=754 data-nosnippet>754</a>}
<a href=#755 id=755 data-nosnippet>755</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#756 id=756 data-nosnippet>756</a>    <span class="attr">#[doc = <span class="string">" Free any dynamically-allocated resources for this language, if\n this is the last reference."</span>]
<a href=#757 id=757 data-nosnippet>757</a>    </span><span class="kw">pub fn </span>ts_language_delete(self_: <span class="kw-2">*const </span>TSLanguage);
<a href=#758 id=758 data-nosnippet>758</a>}
<a href=#759 id=759 data-nosnippet>759</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#760 id=760 data-nosnippet>760</a>    <span class="attr">#[doc = <span class="string">" Get the number of distinct node types in the language."</span>]
<a href=#761 id=761 data-nosnippet>761</a>    </span><span class="kw">pub fn </span>ts_language_symbol_count(self_: <span class="kw-2">*const </span>TSLanguage) -&gt; u32;
<a href=#762 id=762 data-nosnippet>762</a>}
<a href=#763 id=763 data-nosnippet>763</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#764 id=764 data-nosnippet>764</a>    <span class="attr">#[doc = <span class="string">" Get the number of valid states in this language."</span>]
<a href=#765 id=765 data-nosnippet>765</a>    </span><span class="kw">pub fn </span>ts_language_state_count(self_: <span class="kw-2">*const </span>TSLanguage) -&gt; u32;
<a href=#766 id=766 data-nosnippet>766</a>}
<a href=#767 id=767 data-nosnippet>767</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#768 id=768 data-nosnippet>768</a>    <span class="attr">#[doc = <span class="string">" Get the numerical id for the given node type string."</span>]
<a href=#769 id=769 data-nosnippet>769</a>    </span><span class="kw">pub fn </span>ts_language_symbol_for_name(
<a href=#770 id=770 data-nosnippet>770</a>        self_: <span class="kw-2">*const </span>TSLanguage,
<a href=#771 id=771 data-nosnippet>771</a>        string: <span class="kw-2">*const </span>::core::ffi::c_char,
<a href=#772 id=772 data-nosnippet>772</a>        length: u32,
<a href=#773 id=773 data-nosnippet>773</a>        is_named: bool,
<a href=#774 id=774 data-nosnippet>774</a>    ) -&gt; TSSymbol;
<a href=#775 id=775 data-nosnippet>775</a>}
<a href=#776 id=776 data-nosnippet>776</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#777 id=777 data-nosnippet>777</a>    <span class="attr">#[doc = <span class="string">" Get the number of distinct field names in the language."</span>]
<a href=#778 id=778 data-nosnippet>778</a>    </span><span class="kw">pub fn </span>ts_language_field_count(self_: <span class="kw-2">*const </span>TSLanguage) -&gt; u32;
<a href=#779 id=779 data-nosnippet>779</a>}
<a href=#780 id=780 data-nosnippet>780</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#781 id=781 data-nosnippet>781</a>    <span class="attr">#[doc = <span class="string">" Get the field name string for the given numerical id."</span>]
<a href=#782 id=782 data-nosnippet>782</a>    </span><span class="kw">pub fn </span>ts_language_field_name_for_id(
<a href=#783 id=783 data-nosnippet>783</a>        self_: <span class="kw-2">*const </span>TSLanguage,
<a href=#784 id=784 data-nosnippet>784</a>        id: TSFieldId,
<a href=#785 id=785 data-nosnippet>785</a>    ) -&gt; <span class="kw-2">*const </span>::core::ffi::c_char;
<a href=#786 id=786 data-nosnippet>786</a>}
<a href=#787 id=787 data-nosnippet>787</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#788 id=788 data-nosnippet>788</a>    <span class="attr">#[doc = <span class="string">" Get the numerical id for the given field name string."</span>]
<a href=#789 id=789 data-nosnippet>789</a>    </span><span class="kw">pub fn </span>ts_language_field_id_for_name(
<a href=#790 id=790 data-nosnippet>790</a>        self_: <span class="kw-2">*const </span>TSLanguage,
<a href=#791 id=791 data-nosnippet>791</a>        name: <span class="kw-2">*const </span>::core::ffi::c_char,
<a href=#792 id=792 data-nosnippet>792</a>        name_length: u32,
<a href=#793 id=793 data-nosnippet>793</a>    ) -&gt; TSFieldId;
<a href=#794 id=794 data-nosnippet>794</a>}
<a href=#795 id=795 data-nosnippet>795</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#796 id=796 data-nosnippet>796</a>    <span class="attr">#[doc = <span class="string">" Get a list of all supertype symbols for the language."</span>]
<a href=#797 id=797 data-nosnippet>797</a>    </span><span class="kw">pub fn </span>ts_language_supertypes(self_: <span class="kw-2">*const </span>TSLanguage, length: <span class="kw-2">*mut </span>u32) -&gt; <span class="kw-2">*const </span>TSSymbol;
<a href=#798 id=798 data-nosnippet>798</a>}
<a href=#799 id=799 data-nosnippet>799</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#800 id=800 data-nosnippet>800</a>    <span class="attr">#[doc = <span class="string">" Get a list of all subtype symbol ids for a given supertype symbol.\n\n See [`ts_language_supertypes`] for fetching all supertype symbols."</span>]
<a href=#801 id=801 data-nosnippet>801</a>    </span><span class="kw">pub fn </span>ts_language_subtypes(
<a href=#802 id=802 data-nosnippet>802</a>        self_: <span class="kw-2">*const </span>TSLanguage,
<a href=#803 id=803 data-nosnippet>803</a>        supertype: TSSymbol,
<a href=#804 id=804 data-nosnippet>804</a>        length: <span class="kw-2">*mut </span>u32,
<a href=#805 id=805 data-nosnippet>805</a>    ) -&gt; <span class="kw-2">*const </span>TSSymbol;
<a href=#806 id=806 data-nosnippet>806</a>}
<a href=#807 id=807 data-nosnippet>807</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#808 id=808 data-nosnippet>808</a>    <span class="attr">#[doc = <span class="string">" Get a node type string for the given numerical id."</span>]
<a href=#809 id=809 data-nosnippet>809</a>    </span><span class="kw">pub fn </span>ts_language_symbol_name(
<a href=#810 id=810 data-nosnippet>810</a>        self_: <span class="kw-2">*const </span>TSLanguage,
<a href=#811 id=811 data-nosnippet>811</a>        symbol: TSSymbol,
<a href=#812 id=812 data-nosnippet>812</a>    ) -&gt; <span class="kw-2">*const </span>::core::ffi::c_char;
<a href=#813 id=813 data-nosnippet>813</a>}
<a href=#814 id=814 data-nosnippet>814</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#815 id=815 data-nosnippet>815</a>    <span class="attr">#[doc = <span class="string">" Check whether the given node type id belongs to named nodes, anonymous nodes,\n or a hidden nodes.\n\n See also [`ts_node_is_named`]. Hidden nodes are never returned from the API."</span>]
<a href=#816 id=816 data-nosnippet>816</a>    </span><span class="kw">pub fn </span>ts_language_symbol_type(self_: <span class="kw-2">*const </span>TSLanguage, symbol: TSSymbol) -&gt; TSSymbolType;
<a href=#817 id=817 data-nosnippet>817</a>}
<a href=#818 id=818 data-nosnippet>818</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#819 id=819 data-nosnippet>819</a>    <span class="attr">#[doc = <span class="string">" @deprecated use [`ts_language_abi_version`] instead, this will be removed in 0.26.\n\n Get the ABI version number for this language. This version number is used\n to ensure that languages were generated by a compatible version of\n Tree-sitter.\n\n See also [`ts_parser_set_language`]."</span>]
<a href=#820 id=820 data-nosnippet>820</a>    </span><span class="kw">pub fn </span>ts_language_version(self_: <span class="kw-2">*const </span>TSLanguage) -&gt; u32;
<a href=#821 id=821 data-nosnippet>821</a>}
<a href=#822 id=822 data-nosnippet>822</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#823 id=823 data-nosnippet>823</a>    <span class="attr">#[doc = <span class="string">" Get the ABI version number for this language. This version number is used\n to ensure that languages were generated by a compatible version of\n Tree-sitter.\n\n See also [`ts_parser_set_language`]."</span>]
<a href=#824 id=824 data-nosnippet>824</a>    </span><span class="kw">pub fn </span>ts_language_abi_version(self_: <span class="kw-2">*const </span>TSLanguage) -&gt; u32;
<a href=#825 id=825 data-nosnippet>825</a>}
<a href=#826 id=826 data-nosnippet>826</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#827 id=827 data-nosnippet>827</a>    <span class="attr">#[doc = <span class="string">" Get the metadata for this language. This information is generated by the\n CLI, and relies on the language author providing the correct metadata in\n the language's `tree-sitter.json` file.\n\n See also [`TSMetadata`]."</span>]
<a href=#828 id=828 data-nosnippet>828</a>    </span><span class="kw">pub fn </span>ts_language_metadata(self_: <span class="kw-2">*const </span>TSLanguage) -&gt; <span class="kw-2">*const </span>TSLanguageMetadata;
<a href=#829 id=829 data-nosnippet>829</a>}
<a href=#830 id=830 data-nosnippet>830</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#831 id=831 data-nosnippet>831</a>    <span class="attr">#[doc = <span class="string">" Get the next parse state. Combine this with lookahead iterators to generate\n completion suggestions or valid symbols in error nodes. Use\n [`ts_node_grammar_symbol`] for valid symbols."</span>]
<a href=#832 id=832 data-nosnippet>832</a>    </span><span class="kw">pub fn </span>ts_language_next_state(
<a href=#833 id=833 data-nosnippet>833</a>        self_: <span class="kw-2">*const </span>TSLanguage,
<a href=#834 id=834 data-nosnippet>834</a>        state: TSStateId,
<a href=#835 id=835 data-nosnippet>835</a>        symbol: TSSymbol,
<a href=#836 id=836 data-nosnippet>836</a>    ) -&gt; TSStateId;
<a href=#837 id=837 data-nosnippet>837</a>}
<a href=#838 id=838 data-nosnippet>838</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#839 id=839 data-nosnippet>839</a>    <span class="attr">#[doc = <span class="string">" Get the name of this language. This returns `NULL` in older parsers."</span>]
<a href=#840 id=840 data-nosnippet>840</a>    </span><span class="kw">pub fn </span>ts_language_name(self_: <span class="kw-2">*const </span>TSLanguage) -&gt; <span class="kw-2">*const </span>::core::ffi::c_char;
<a href=#841 id=841 data-nosnippet>841</a>}
<a href=#842 id=842 data-nosnippet>842</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#843 id=843 data-nosnippet>843</a>    <span class="attr">#[doc = <span class="string">" Create a new lookahead iterator for the given language and parse state.\n\n This returns `NULL` if state is invalid for the language.\n\n Repeatedly using [`ts_lookahead_iterator_next`] and\n [`ts_lookahead_iterator_current_symbol`] will generate valid symbols in the\n given parse state. Newly created lookahead iterators will contain the `ERROR`\n symbol.\n\n Lookahead iterators can be useful to generate suggestions and improve syntax\n error diagnostics. To get symbols valid in an ERROR node, use the lookahead\n iterator on its first leaf node state. For `MISSING` nodes, a lookahead\n iterator created on the previous non-extra leaf node may be appropriate."</span>]
<a href=#844 id=844 data-nosnippet>844</a>    </span><span class="kw">pub fn </span>ts_lookahead_iterator_new(
<a href=#845 id=845 data-nosnippet>845</a>        self_: <span class="kw-2">*const </span>TSLanguage,
<a href=#846 id=846 data-nosnippet>846</a>        state: TSStateId,
<a href=#847 id=847 data-nosnippet>847</a>    ) -&gt; <span class="kw-2">*mut </span>TSLookaheadIterator;
<a href=#848 id=848 data-nosnippet>848</a>}
<a href=#849 id=849 data-nosnippet>849</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#850 id=850 data-nosnippet>850</a>    <span class="attr">#[doc = <span class="string">" Delete a lookahead iterator freeing all the memory used."</span>]
<a href=#851 id=851 data-nosnippet>851</a>    </span><span class="kw">pub fn </span>ts_lookahead_iterator_delete(self_: <span class="kw-2">*mut </span>TSLookaheadIterator);
<a href=#852 id=852 data-nosnippet>852</a>}
<a href=#853 id=853 data-nosnippet>853</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#854 id=854 data-nosnippet>854</a>    <span class="attr">#[doc = <span class="string">" Reset the lookahead iterator to another state.\n\n This returns `true` if the iterator was reset to the given state and `false`\n otherwise."</span>]
<a href=#855 id=855 data-nosnippet>855</a>    </span><span class="kw">pub fn </span>ts_lookahead_iterator_reset_state(
<a href=#856 id=856 data-nosnippet>856</a>        self_: <span class="kw-2">*mut </span>TSLookaheadIterator,
<a href=#857 id=857 data-nosnippet>857</a>        state: TSStateId,
<a href=#858 id=858 data-nosnippet>858</a>    ) -&gt; bool;
<a href=#859 id=859 data-nosnippet>859</a>}
<a href=#860 id=860 data-nosnippet>860</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#861 id=861 data-nosnippet>861</a>    <span class="attr">#[doc = <span class="string">" Reset the lookahead iterator.\n\n This returns `true` if the language was set successfully and `false`\n otherwise."</span>]
<a href=#862 id=862 data-nosnippet>862</a>    </span><span class="kw">pub fn </span>ts_lookahead_iterator_reset(
<a href=#863 id=863 data-nosnippet>863</a>        self_: <span class="kw-2">*mut </span>TSLookaheadIterator,
<a href=#864 id=864 data-nosnippet>864</a>        language: <span class="kw-2">*const </span>TSLanguage,
<a href=#865 id=865 data-nosnippet>865</a>        state: TSStateId,
<a href=#866 id=866 data-nosnippet>866</a>    ) -&gt; bool;
<a href=#867 id=867 data-nosnippet>867</a>}
<a href=#868 id=868 data-nosnippet>868</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#869 id=869 data-nosnippet>869</a>    <span class="attr">#[doc = <span class="string">" Get the current language of the lookahead iterator."</span>]
<a href=#870 id=870 data-nosnippet>870</a>    </span><span class="kw">pub fn </span>ts_lookahead_iterator_language(self_: <span class="kw-2">*const </span>TSLookaheadIterator) -&gt; <span class="kw-2">*const </span>TSLanguage;
<a href=#871 id=871 data-nosnippet>871</a>}
<a href=#872 id=872 data-nosnippet>872</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#873 id=873 data-nosnippet>873</a>    <span class="attr">#[doc = <span class="string">" Advance the lookahead iterator to the next symbol.\n\n This returns `true` if there is a new symbol and `false` otherwise."</span>]
<a href=#874 id=874 data-nosnippet>874</a>    </span><span class="kw">pub fn </span>ts_lookahead_iterator_next(self_: <span class="kw-2">*mut </span>TSLookaheadIterator) -&gt; bool;
<a href=#875 id=875 data-nosnippet>875</a>}
<a href=#876 id=876 data-nosnippet>876</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#877 id=877 data-nosnippet>877</a>    <span class="attr">#[doc = <span class="string">" Get the current symbol of the lookahead iterator;"</span>]
<a href=#878 id=878 data-nosnippet>878</a>    </span><span class="kw">pub fn </span>ts_lookahead_iterator_current_symbol(self_: <span class="kw-2">*const </span>TSLookaheadIterator) -&gt; TSSymbol;
<a href=#879 id=879 data-nosnippet>879</a>}
<a href=#880 id=880 data-nosnippet>880</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#881 id=881 data-nosnippet>881</a>    <span class="attr">#[doc = <span class="string">" Get the current symbol type of the lookahead iterator as a null terminated\n string."</span>]
<a href=#882 id=882 data-nosnippet>882</a>    </span><span class="kw">pub fn </span>ts_lookahead_iterator_current_symbol_name(
<a href=#883 id=883 data-nosnippet>883</a>        self_: <span class="kw-2">*const </span>TSLookaheadIterator,
<a href=#884 id=884 data-nosnippet>884</a>    ) -&gt; <span class="kw-2">*const </span>::core::ffi::c_char;
<a href=#885 id=885 data-nosnippet>885</a>}
<a href=#886 id=886 data-nosnippet>886</a><span class="attr">#[repr(C)]
<a href=#887 id=887 data-nosnippet>887</a>#[derive(Debug, Copy, Clone)]
<a href=#888 id=888 data-nosnippet>888</a></span><span class="kw">pub struct </span>wasm_engine_t {
<a href=#889 id=889 data-nosnippet>889</a>    _unused: [u8; <span class="number">0</span>],
<a href=#890 id=890 data-nosnippet>890</a>}
<a href=#891 id=891 data-nosnippet>891</a><span class="kw">pub type </span>TSWasmEngine = wasm_engine_t;
<a href=#892 id=892 data-nosnippet>892</a><span class="attr">#[repr(C)]
<a href=#893 id=893 data-nosnippet>893</a>#[derive(Debug, Copy, Clone)]
<a href=#894 id=894 data-nosnippet>894</a></span><span class="kw">pub struct </span>TSWasmStore {
<a href=#895 id=895 data-nosnippet>895</a>    _unused: [u8; <span class="number">0</span>],
<a href=#896 id=896 data-nosnippet>896</a>}
<a href=#897 id=897 data-nosnippet>897</a><span class="kw">pub const </span>TSWasmErrorKindNone: TSWasmErrorKind = <span class="number">0</span>;
<a href=#898 id=898 data-nosnippet>898</a><span class="kw">pub const </span>TSWasmErrorKindParse: TSWasmErrorKind = <span class="number">1</span>;
<a href=#899 id=899 data-nosnippet>899</a><span class="kw">pub const </span>TSWasmErrorKindCompile: TSWasmErrorKind = <span class="number">2</span>;
<a href=#900 id=900 data-nosnippet>900</a><span class="kw">pub const </span>TSWasmErrorKindInstantiate: TSWasmErrorKind = <span class="number">3</span>;
<a href=#901 id=901 data-nosnippet>901</a><span class="kw">pub const </span>TSWasmErrorKindAllocate: TSWasmErrorKind = <span class="number">4</span>;
<a href=#902 id=902 data-nosnippet>902</a><span class="kw">pub type </span>TSWasmErrorKind = ::core::ffi::c_uint;
<a href=#903 id=903 data-nosnippet>903</a><span class="attr">#[repr(C)]
<a href=#904 id=904 data-nosnippet>904</a>#[derive(Debug, Copy, Clone)]
<a href=#905 id=905 data-nosnippet>905</a></span><span class="kw">pub struct </span>TSWasmError {
<a href=#906 id=906 data-nosnippet>906</a>    <span class="kw">pub </span>kind: TSWasmErrorKind,
<a href=#907 id=907 data-nosnippet>907</a>    <span class="kw">pub </span>message: <span class="kw-2">*mut </span>::core::ffi::c_char,
<a href=#908 id=908 data-nosnippet>908</a>}
<a href=#909 id=909 data-nosnippet>909</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#910 id=910 data-nosnippet>910</a>    <span class="attr">#[doc = <span class="string">" Create a Wasm store."</span>]
<a href=#911 id=911 data-nosnippet>911</a>    </span><span class="kw">pub fn </span>ts_wasm_store_new(
<a href=#912 id=912 data-nosnippet>912</a>        engine: <span class="kw-2">*mut </span>TSWasmEngine,
<a href=#913 id=913 data-nosnippet>913</a>        error: <span class="kw-2">*mut </span>TSWasmError,
<a href=#914 id=914 data-nosnippet>914</a>    ) -&gt; <span class="kw-2">*mut </span>TSWasmStore;
<a href=#915 id=915 data-nosnippet>915</a>}
<a href=#916 id=916 data-nosnippet>916</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#917 id=917 data-nosnippet>917</a>    <span class="attr">#[doc = <span class="string">" Free the memory associated with the given Wasm store."</span>]
<a href=#918 id=918 data-nosnippet>918</a>    </span><span class="kw">pub fn </span>ts_wasm_store_delete(arg1: <span class="kw-2">*mut </span>TSWasmStore);
<a href=#919 id=919 data-nosnippet>919</a>}
<a href=#920 id=920 data-nosnippet>920</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#921 id=921 data-nosnippet>921</a>    <span class="attr">#[doc = <span class="string">" Create a language from a buffer of Wasm. The resulting language behaves\n like any other Tree-sitter language, except that in order to use it with\n a parser, that parser must have a Wasm store. Note that the language\n can be used with any Wasm store, it doesn't need to be the same store that\n was used to originally load it."</span>]
<a href=#922 id=922 data-nosnippet>922</a>    </span><span class="kw">pub fn </span>ts_wasm_store_load_language(
<a href=#923 id=923 data-nosnippet>923</a>        arg1: <span class="kw-2">*mut </span>TSWasmStore,
<a href=#924 id=924 data-nosnippet>924</a>        name: <span class="kw-2">*const </span>::core::ffi::c_char,
<a href=#925 id=925 data-nosnippet>925</a>        wasm: <span class="kw-2">*const </span>::core::ffi::c_char,
<a href=#926 id=926 data-nosnippet>926</a>        wasm_len: u32,
<a href=#927 id=927 data-nosnippet>927</a>        error: <span class="kw-2">*mut </span>TSWasmError,
<a href=#928 id=928 data-nosnippet>928</a>    ) -&gt; <span class="kw-2">*const </span>TSLanguage;
<a href=#929 id=929 data-nosnippet>929</a>}
<a href=#930 id=930 data-nosnippet>930</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#931 id=931 data-nosnippet>931</a>    <span class="attr">#[doc = <span class="string">" Get the number of languages instantiated in the given wasm store."</span>]
<a href=#932 id=932 data-nosnippet>932</a>    </span><span class="kw">pub fn </span>ts_wasm_store_language_count(arg1: <span class="kw-2">*const </span>TSWasmStore) -&gt; usize;
<a href=#933 id=933 data-nosnippet>933</a>}
<a href=#934 id=934 data-nosnippet>934</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#935 id=935 data-nosnippet>935</a>    <span class="attr">#[doc = <span class="string">" Check if the language came from a Wasm module. If so, then in order to use\n this language with a Parser, that parser must have a Wasm store assigned."</span>]
<a href=#936 id=936 data-nosnippet>936</a>    </span><span class="kw">pub fn </span>ts_language_is_wasm(arg1: <span class="kw-2">*const </span>TSLanguage) -&gt; bool;
<a href=#937 id=937 data-nosnippet>937</a>}
<a href=#938 id=938 data-nosnippet>938</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#939 id=939 data-nosnippet>939</a>    <span class="attr">#[doc = <span class="string">" Assign the given Wasm store to the parser. A parser must have a Wasm store\n in order to use Wasm languages."</span>]
<a href=#940 id=940 data-nosnippet>940</a>    </span><span class="kw">pub fn </span>ts_parser_set_wasm_store(arg1: <span class="kw-2">*mut </span>TSParser, arg2: <span class="kw-2">*mut </span>TSWasmStore);
<a href=#941 id=941 data-nosnippet>941</a>}
<a href=#942 id=942 data-nosnippet>942</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#943 id=943 data-nosnippet>943</a>    <span class="attr">#[doc = <span class="string">" Remove the parser's current Wasm store and return it. This returns NULL if\n the parser doesn't have a Wasm store."</span>]
<a href=#944 id=944 data-nosnippet>944</a>    </span><span class="kw">pub fn </span>ts_parser_take_wasm_store(arg1: <span class="kw-2">*mut </span>TSParser) -&gt; <span class="kw-2">*mut </span>TSWasmStore;
<a href=#945 id=945 data-nosnippet>945</a>}
<a href=#946 id=946 data-nosnippet>946</a><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#947 id=947 data-nosnippet>947</a>    <span class="attr">#[doc = <span class="string">" Set the allocation functions used by the library.\n\n By default, Tree-sitter uses the standard libc allocation functions,\n but aborts the process when an allocation fails. This function lets\n you supply alternative allocation functions at runtime.\n\n If you pass `NULL` for any parameter, Tree-sitter will switch back to\n its default implementation of that function.\n\n If you call this function after the library has already been used, then\n you must ensure that either:\n  1. All the existing objects have been freed.\n  2. The new allocator shares its state with the old one, so it is capable\n     of freeing memory that was allocated by the old allocator."</span>]
<a href=#948 id=948 data-nosnippet>948</a>    </span><span class="kw">pub fn </span>ts_set_allocator(
<a href=#949 id=949 data-nosnippet>949</a>        new_malloc: ::core::option::Option&lt;
<a href=#950 id=950 data-nosnippet>950</a>            <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn</span>(arg1: usize) -&gt; <span class="kw-2">*mut </span>::core::ffi::c_void,
<a href=#951 id=951 data-nosnippet>951</a>        &gt;,
<a href=#952 id=952 data-nosnippet>952</a>        new_calloc: ::core::option::Option&lt;
<a href=#953 id=953 data-nosnippet>953</a>            <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn</span>(arg1: usize, arg2: usize) -&gt; <span class="kw-2">*mut </span>::core::ffi::c_void,
<a href=#954 id=954 data-nosnippet>954</a>        &gt;,
<a href=#955 id=955 data-nosnippet>955</a>        new_realloc: ::core::option::Option&lt;
<a href=#956 id=956 data-nosnippet>956</a>            <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn</span>(
<a href=#957 id=957 data-nosnippet>957</a>                arg1: <span class="kw-2">*mut </span>::core::ffi::c_void,
<a href=#958 id=958 data-nosnippet>958</a>                arg2: usize,
<a href=#959 id=959 data-nosnippet>959</a>            ) -&gt; <span class="kw-2">*mut </span>::core::ffi::c_void,
<a href=#960 id=960 data-nosnippet>960</a>        &gt;,
<a href=#961 id=961 data-nosnippet>961</a>        new_free: ::core::option::Option&lt;<span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn</span>(arg1: <span class="kw-2">*mut </span>::core::ffi::c_void)&gt;,
<a href=#962 id=962 data-nosnippet>962</a>    );
<a href=#963 id=963 data-nosnippet>963</a>}</code></pre></div></section></main></body></html>