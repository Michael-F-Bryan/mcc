<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Use the parser to parse some source code and create a syntax tree."><title>ts_parser_parse in tree_sitter::ffi - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-1a91846b.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="tree_sitter" data-themes="" data-resource-suffix="" data-rustdoc-version="1.88.0 (6b00bc388 2025-06-23)" data-channel="1.88.0" data-search-js="search-f7877310.js" data-settings-js="settings-5514c975.js" ><script src="../../static.files/storage-4e99c027.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-7ef8a74a.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../tree_sitter/index.html">tree_<wbr>sitter</a><span class="version">0.25.8</span></h2></div><div class="sidebar-elems"><div id="rustdoc-modnav"><h2><a href="index.html">In tree_<wbr>sitter::<wbr>ffi</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">tree_sitter</a>::<wbr><a href="index.html">ffi</a></div><h1>Function <span class="fn">ts_parser_parse</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/tree_sitter/bindings.rs.html#222-226">Source</a> </span></div><pre class="rust item-decl"><code>pub unsafe extern &quot;C&quot; fn ts_parser_parse(
    self_: <a class="primitive" href="https://doc.rust-lang.org/1.88.0/std/primitive.pointer.html">*mut </a><a class="struct" href="struct.TSParser.html" title="struct tree_sitter::ffi::TSParser">TSParser</a>,
    old_tree: <a class="primitive" href="https://doc.rust-lang.org/1.88.0/std/primitive.pointer.html">*const </a><a class="struct" href="struct.TSTree.html" title="struct tree_sitter::ffi::TSTree">TSTree</a>,
    input: <a class="struct" href="struct.TSInput.html" title="struct tree_sitter::ffi::TSInput">TSInput</a>,
) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.88.0/std/primitive.pointer.html">*mut </a><a class="struct" href="struct.TSTree.html" title="struct tree_sitter::ffi::TSTree">TSTree</a></code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Use the parser to parse some source code and create a syntax tree.</p>
<p>If you are parsing this document for the first time, pass <code>NULL</code> for the
<code>old_tree</code> parameter. Otherwise, if you have already parsed an earlier
version of this document and the document has since been edited, pass the
previous syntax tree so that the unchanged parts of it can be reused.
This will save time and memory. For this to work correctly, you must have
already edited the old syntax tree using the <a href="fn.ts_tree_edit.html" title="fn tree_sitter::ffi::ts_tree_edit"><code>ts_tree_edit</code></a> function in a
way that exactly matches the source code changes.</p>
<p>The <a href="struct.TSInput.html" title="struct tree_sitter::ffi::TSInput"><code>TSInput</code></a> parameter lets you specify how to read the text. It has the
following three fields:</p>
<ol>
<li><a href="struct.TSInput.html#structfield.read" title="field tree_sitter::ffi::TSInput::read"><code>read</code></a>: A function to retrieve a chunk of text at a given byte offset
and (row, column) position. The function should return a pointer to the
text and write its length to the <a href="struct.TSInput.html#structfield.read" title="field tree_sitter::ffi::TSInput::read"><code>bytes_read</code></a> pointer. The parser does
not take ownership of this buffer; it just borrows it until it has
finished reading it. The function should write a zero value to the
<a href="struct.TSInput.html#structfield.read" title="field tree_sitter::ffi::TSInput::read"><code>bytes_read</code></a> pointer to indicate the end of the document.</li>
<li><a href="struct.TSInput.html#structfield.payload" title="field tree_sitter::ffi::TSInput::payload"><code>payload</code></a>: An arbitrary pointer that will be passed to each invocation
of the <a href="struct.TSInput.html#structfield.read" title="field tree_sitter::ffi::TSInput::read"><code>read</code></a> function.</li>
<li><a href="struct.TSInput.html#structfield.encoding" title="field tree_sitter::ffi::TSInput::encoding"><code>encoding</code></a>: An indication of how the text is encoded. Either
<code>TSInputEncodingUTF8</code> or <code>TSInputEncodingUTF16</code>.</li>
</ol>
<p>This function returns a syntax tree on success, and <code>NULL</code> on failure. There
are four possible reasons for failure:</p>
<ol>
<li>The parser does not have a language assigned. Check for this using the
<a href="fn.ts_parser_language.html" title="fn tree_sitter::ffi::ts_parser_language"><code>ts_parser_language</code></a> function.</li>
<li>Parsing was cancelled due to a timeout that was set by an earlier call to
the <a href="fn.ts_parser_set_timeout_micros.html" title="fn tree_sitter::ffi::ts_parser_set_timeout_micros"><code>ts_parser_set_timeout_micros</code></a> function. You can resume parsing from
where the parser left out by calling <a href="fn.ts_parser_parse.html" title="fn tree_sitter::ffi::ts_parser_parse"><code>ts_parser_parse</code></a> again with the
same arguments. Or you can start parsing from scratch by first calling
<a href="fn.ts_parser_reset.html" title="fn tree_sitter::ffi::ts_parser_reset"><code>ts_parser_reset</code></a>.</li>
<li>Parsing was cancelled using a cancellation flag that was set by an
earlier call to <a href="fn.ts_parser_set_cancellation_flag.html" title="fn tree_sitter::ffi::ts_parser_set_cancellation_flag"><code>ts_parser_set_cancellation_flag</code></a>. You can resume parsing
from where the parser left out by calling <a href="fn.ts_parser_parse.html" title="fn tree_sitter::ffi::ts_parser_parse"><code>ts_parser_parse</code></a> again with
the same arguments.</li>
<li>Parsing was cancelled due to the progress callback returning true. This callback
is passed in <a href="fn.ts_parser_parse_with_options.html" title="fn tree_sitter::ffi::ts_parser_parse_with_options"><code>ts_parser_parse_with_options</code></a> inside the <a href="struct.TSParseOptions.html" title="struct tree_sitter::ffi::TSParseOptions"><code>TSParseOptions</code></a> struct.</li>
</ol>
</div></details></section></div></main></body></html>